<%
	proc ld x "expr {int(log(\$x)/[expr log(2)])}"
	
	proc getAddrBits {registerfile} {
		set addrBits [ld [expr [$registerfile size]/8]]
		incr addrBits 3
		return $addrBits
	}
	
	proc writeTemplate {object} {
		set first 0
		$object onEachComponent {
			if {[$it isa osys::rfg::Group]} {
				writeTemplate $it
			} else {
				set register $it
				$it onEachField {
					if {$first != 0} {
						puts ","	
					}
					puts  -nonewline "	.[$register name]_[$it name]()"
					set first 1				
				}
			}
		}

	}
	
	proc writeBlackbox {object} {
		$object onEachComponent {
			if {[$it isa osys::rfg::Group]} {
				writeBlackbox $it
			} else {
				set register $it
				$it onEachField {
					if {[$it hasAttribute hardware.global.rw]} {
						if {[$it width] == 1} {
							puts "	input wire [$register name]_[$it name]_next;"
							puts "	output reg [$register name]_[$it name];"
						} else {
							puts "	input wire\[[expr {[$it width]-1}]:0\] [$register name]_[$it name]_next;"
							puts "	output reg\[[expr {[$it width]-1}]:0\] [$register name]_[$it name];"
						}
					} elseif {[$it hasAttribute hardware.global.wo]} {
						if {[$it width] == 1} {
							puts "	input wire [$register name]_[$it name]_next;"
						} else {
							puts "	input wire\[[expr {[$it width]-1}]:0\] [$register name]_[$it name]_next;"
						}
					} elseif {[$it hasAttribute hardware.global.ro]} {
						if {[$it width] == 1} {
							puts "	output reg [$register name]_[$it name];"
						} else {
							puts "	output reg\[[expr {[$it width]-1}]:0\] [$register name]_[$it name];"
						}
					} 
				}
			}
		}
	}

	proc writeRegisternames {object} {
		$object onEachComponent {
			if {[$it isa osys::rfg::Group]} {
				writeRegisternames $it
			} else {
				set register $it
				$it onEachField {
					if {![$it hasAttribute hardware.global.ro] && ![$it hasAttribute hardware.global.rw]} {
						if {[$it width] == 1} {
							puts "	reg [$register name]_[$it name];"
						} else {
							puts "	reg\[[expr {[$it width]-1}]:0\] [$register name]_[$it name];"
						}
					}
				}
			}
		}
	}

	proc writeRegister {object} {
		$object onEachComponent {
			if {[$it isa osys::rfg::Group]} {
				writeRegister $it
			} else {
				puts "	/* register [$it name] */"
				puts "	`ifdef ASYNC_RES"
				puts "	always @(posedge clk or negedge res_n) `else"
				puts "	always @(posedge clk) `endif"
				puts "	begin"
				puts "		if (!res_n)"
				puts "		begin"
				set register $it
				$it onEachField {
					puts "			[$register name]_[$it name] <= [$it reset];"
				}
				puts "		end"
				puts "		else"
				puts "		begin"
				set register $it 
			 	$it onEachField {
					if {[$it hasAttribute hardware.global.wo] || [$it hasAttribute hardware.global.rw]} {
						puts "			[$register name]_[$it name] <= [$register name]_[$it name]_next;"		
					}
				}
				set reg_size [expr [$object size]/8]
				#set addrBits [ld [expr [$object size]/8]]
				set register $it
				set lowerBound 0
				$it onEachField {
					set upperBound [expr $lowerBound+[$it width]]
					if {[$it hasAttribute software.global.wo] || [$it hasAttribute software.global.rw]} {
						puts "			if((address\[[expr [getAddrBits $registerFile]-1]:3\]== [expr [$register getAbsoluteAddress]/8]) && write_en)"
						puts "			begin"
						puts "				[$register name]_[$it name] <= write_data\[[expr $upperBound-1]:$lowerBound\];"
						puts "			end"

					}
					incr lowerBound [$it width]
				}
				puts "		end"
				puts "	end"
				puts ""
			}
		}
	}

	proc writeAddressControl {$object} {
		
	}
%>
/* auto generated by RFG */
/*
<%puts -nonewline "[$registerFile name] [$registerFile name]"%>_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
<% writeTemplate $registerFile %>);
*/
module <%puts [$registerFile name]%>(
	///\defgroup sys
	///@{ 
	input wire res_n,
	input wire clk,
	///}@ 
	///\defgroup rw_if
	///@{ 
	input wire[<% puts -nonewline "[expr [getAddrBits $registerFile]-1]"%>:3] address,
	output reg[63:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[63:0] write_data,
	///}@ 
<% writeBlackbox $registerFile %>);

<% writeRegisternames $registerFile %>

<% writeRegister $registerFile %>
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			invalid_address      <= 1'b0;
			access_complete      <= 1'b0;
			`ifdef ASIC
			read_data   <= 64'b0;
			`endif
		end
		else
		begin
			casex(address[<% puts -nonewline "[expr [getAddrBits $registerFile]-1]"%>:3])
<% writeAddressControl $registerFile %>
			endcase
		end
	end
endmodule;