/* auto generated by RFG */
/* address map
counter_rreinit: base[3:3] 0 size: 8
example: base[3:3] 1 size: 8
*/
/* instantiation template
reg_hrw_srw_rreinit_source reg_hrw_srw_rreinit_source_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
	.example_test_field_next(),
	.example_test_field(),
	.example_test_field_wen(),
	.example_test_field_countup()
);
*/
module reg_hrw_srw_rreinit_source
(
	input wire res_n,
	input wire clk,
	// Software Interface
	input wire[3:3] address,
	output reg[31:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[31:0] write_data,
	// Hardware Interface
	input wire[31:0] example_test_field_next,
	output wire[31:0] example_test_field,
	input wire example_test_field_wen,
	input wire example_test_field_countup
);

	reg rreinit;
	reg example_test_field_load_enable;
	reg[31:0] example_test_field_load_value;

	counter48 #(
		.DATASIZE(32)
	) example_test_field_I (
		.clk(clk),
		.res_n(res_n),
		.increment(example_test_field_countup),
		.load(example_test_field_load_value),
		.load_enable(rreinit || example_test_field_load_enable),
		.value(example_test_field)
	);

	/* register counter_rreinit */
	always @(posedge clk)
	begin
		if (!res_n)
		begin
			rreinit <= 1'b0;
		end
		else
		begin

			if((address[3:3]== 0) && write_en)
			begin
				rreinit <= 1'b1;
			end
			else
			begin
				rreinit <= 1'b0;
			end
		end
	end

	/* register example */
	always @(posedge clk)
	begin
		if (!res_n)
		begin
			example_test_field_load_enable <= 1'b0;
		end
		else
		begin

			if((address[3:3]== 1) && write_en)
			begin
				example_test_field_load_enable <= 1'b1;
				example_test_field_load_value <= write_data[31:0];
			end
			else if(example_test_field_wen)
			begin
				example_test_field_load_value <= example_test_field_next;
				example_test_field_load_enable <= 1'b1;
			end
			else
			begin
				example_test_field_load_enable <= 1'b0;
				example_test_field_load_value <= 32'b0;
			end
		end
	end
	
    always @(posedge clk)
	begin
		if (!res_n)
		begin
			invalid_address <= 1'b0;
			access_complete <= 1'b0;
		end
		else
		begin

			casex(address[3:3])
				1'h1:
				begin
					read_data[31:0] <= example_test_field;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				default:
				begin
					invalid_address <= read_en || write_en;
					access_complete <= read_en || write_en;
				end		
			endcase
		end
	end
endmodule
