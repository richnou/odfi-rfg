

/* auto generated by RFG */
/* address map
status: base: 0x0 size: 8
counter_reset: base: 0x8 size: 8
bit_slip_0: base: 0x10 size: 8
bit_slip_1: base: 0x18 size: 8
bit_slip_2: base: 0x20 size: 8
bit_slip_3: base: 0x28 size: 8
bit_slip_4: base: 0x30 size: 8
bit_slip_5: base: 0x38 size: 8
bit_slip_6: base: 0x40 size: 8
bit_slip_7: base: 0x48 size: 8

*/
/* instantiation template
phy_rf phy_rf_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
	.status_reset_done_next(),
	.bit_slip_0_count_countup(),
	.bit_slip_1_count_countup(),
	.bit_slip_2_count_countup(),
	.bit_slip_3_count_countup(),
	.bit_slip_4_count_countup(),
	.bit_slip_5_count_countup(),
	.bit_slip_6_count_countup(),
	.bit_slip_7_count_countup()
);
*/
module phy_rf
(
	///\defgroup sys
	///@{ 
	input wire res_n,
	input wire clk,
	///}@ 
	///\defgroup rw_if
	///@{ 
	input wire[6:3] address,
	output reg[9:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[9:0] write_data,
	///}@ 
	input wire status_reset_done_next,
	input wire bit_slip_0_count_countup,
	input wire bit_slip_1_count_countup,
	input wire bit_slip_2_count_countup,
	input wire bit_slip_3_count_countup,
	input wire bit_slip_4_count_countup,
	input wire bit_slip_5_count_countup,
	input wire bit_slip_6_count_countup,
	input wire bit_slip_7_count_countup

);

	reg status_reset_done;
	reg rreinit;
	wire[9:0] bit_slip_0_count;
	wire[9:0] bit_slip_1_count;
	wire[9:0] bit_slip_2_count;
	wire[9:0] bit_slip_3_count;
	wire[9:0] bit_slip_4_count;
	wire[9:0] bit_slip_5_count;
	wire[9:0] bit_slip_6_count;
	wire[9:0] bit_slip_7_count;

	counter48 #(
		.DATASIZE(10)
	) bit_slip_0_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_0_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_0_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_1_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_1_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_1_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_2_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_2_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_2_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_3_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_3_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_3_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_4_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_4_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_4_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_5_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_5_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_5_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_6_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_6_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_6_count)
	);

	counter48 #(
		.DATASIZE(10)
	) bit_slip_7_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(bit_slip_7_count_countup),
 		.load(10'b0),
		.load_enable(rreinit),
		.value(bit_slip_7_count)
	);


	/* register status */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			status_reset_done <= 1'h0;
		end
		else
		begin

				status_reset_done <= status_reset_done_next;
		end
	end

	/* register counter_reset */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			rreinit <= 1'b0;
		end
		else
		begin

			if((address[6:3]== 1) && write_en)
			begin
				rreinit <= 1'b1;
			end
			else
			begin
				rreinit <= 1'b0;
			end
		end
	end

	/* register bit_slip_0 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_1 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_2 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_3 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_4 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_5 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_6 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register bit_slip_7 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end


	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			invalid_address <= 1'b0;
			access_complete <= 1'b0;
			`ifdef ASIC
			read_data   <= 10'b0;
			`endif

		end
		else
		begin

			casex(address[6:3])
				4'h0:
				begin
					read_data[0:0] <= status_reset_done;
					read_data[9:1] <= 9'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h2:
				begin
					read_data[9:0] <= bit_slip_0_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h3:
				begin
					read_data[9:0] <= bit_slip_1_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h4:
				begin
					read_data[9:0] <= bit_slip_2_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h5:
				begin
					read_data[9:0] <= bit_slip_3_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h6:
				begin
					read_data[9:0] <= bit_slip_4_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h7:
				begin
					read_data[9:0] <= bit_slip_5_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h8:
				begin
					read_data[9:0] <= bit_slip_6_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h9:
				begin
					read_data[9:0] <= bit_slip_7_count;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				default:
				begin
					invalid_address <= read_en || write_en;
					access_complete <= read_en || write_en;
				end		
			endcase
		end
	end
endmodule