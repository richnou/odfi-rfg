

/* auto generated by RFG */
/* address map
status: base: 0x0 size: 8
control: base: 0x8 size: 8
counter_reset: base: 0x10 size: 8
link_retries: base: 0x18 size: 8
poisoned_packets: base: 0x20 size: 8
sent_np: base: 0x28 size: 8
sent_p: base: 0x30 size: 8
sent_r: base: 0x38 size: 8
rcvd_rsp: base: 0x40 size: 8

*/
/* instantiation template
hmc_rf hmc_rf_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
	.status_link_up_next(),
	.status_link_training_next(),
	.status_descramblers_aligned_next(),
	.status_sleep_mode_next(),
	.status_lanes_reversed_next(),
	.status_tx_init_NULL_1_next(),
	.status_tx_init_TS1_next(),
	.status_tx_init_NULL_2_next(),
	.status_hmc_init_TS1_next(),
	.status_hmc_init_NULL_2_next(),
	.status_hmc_init_TRET_next(),
	.status_token_count_next(),
	.status_lane_polarity_reversed_next(),
	.status_lane_descramblers_locked_next(),
	.status_phy_ready_next(),
	.control_put_hmc_in_sleep_mode(),
	.control_scrambler_disable(),
	.control_upper_lanes(),
	.control_p_rst_n(),
	.control_first_cube_ID(),
	.control_rx_token_count(),
	.control_bit_slip_time(),
	.control_irtry_received_threshold(),
	.control_irtry_to_send(),
	.link_retries_count_countup(),
	.poisoned_packets_count_countup(),
	.sent_np_count_countup(),
	.sent_p_count_countup(),
	.sent_r_count_countup(),
	.rcvd_rsp_count_countup()
);
*/
module hmc_rf
(
	///\defgroup sys
	///@{ 
	input wire res_n,
	input wire clk,
	///}@ 
	///\defgroup rw_if
	///@{ 
	input wire[6:3] address,
	output reg[63:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[63:0] write_data,
	///}@ 
	input wire status_link_up_next,
	input wire status_link_training_next,
	input wire status_descramblers_aligned_next,
	input wire status_sleep_mode_next,
	input wire status_lanes_reversed_next,
	input wire status_tx_init_NULL_1_next,
	input wire status_tx_init_TS1_next,
	input wire status_tx_init_NULL_2_next,
	input wire status_hmc_init_TS1_next,
	input wire status_hmc_init_NULL_2_next,
	input wire status_hmc_init_TRET_next,
	input wire[9:0] status_token_count_next,
	input wire[3:0] status_lane_polarity_reversed_next,
	input wire[3:0] status_lane_descramblers_locked_next,
	input wire status_phy_ready_next,
	output reg control_put_hmc_in_sleep_mode,
	output reg control_scrambler_disable,
	output reg control_upper_lanes,
	output reg control_p_rst_n,
	output reg[2:0] control_first_cube_ID,
	output reg[9:0] control_rx_token_count,
	output reg[7:0] control_bit_slip_time,
	output reg[4:0] control_irtry_received_threshold,
	output reg[4:0] control_irtry_to_send,
	input wire link_retries_count_countup,
	input wire poisoned_packets_count_countup,
	input wire sent_np_count_countup,
	input wire sent_p_count_countup,
	input wire sent_r_count_countup,
	input wire rcvd_rsp_count_countup

);

	reg status_link_up;
	reg status_link_training;
	reg status_descramblers_aligned;
	reg status_sleep_mode;
	reg status_lanes_reversed;
	reg[2:0] status_rsvd0;
	reg status_tx_init_NULL_1;
	reg status_tx_init_TS1;
	reg status_tx_init_NULL_2;
	reg status_hmc_init_TS1;
	reg status_hmc_init_NULL_2;
	reg status_hmc_init_TRET;
	reg[1:0] status_rsvd1;
	reg[9:0] status_token_count;
	reg[5:0] status_rsvd2;
	reg[3:0] status_lane_polarity_reversed;
	reg[3:0] status_lane_descramblers_locked;
	reg status_phy_ready;
	reg[5:0] control_rsvd_control_2;
	reg rreinit;
	wire[31:0] link_retries_count;
	wire[31:0] poisoned_packets_count;
	wire[31:0] sent_np_count;
	wire[31:0] sent_p_count;
	wire[31:0] sent_r_count;
	wire[31:0] rcvd_rsp_count;

	counter48 #(
		.DATASIZE(32)
	) link_retries_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(link_retries_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(link_retries_count)
	);

	counter48 #(
		.DATASIZE(32)
	) poisoned_packets_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(poisoned_packets_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(poisoned_packets_count)
	);

	counter48 #(
		.DATASIZE(32)
	) sent_np_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(sent_np_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(sent_np_count)
	);

	counter48 #(
		.DATASIZE(32)
	) sent_p_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(sent_p_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(sent_p_count)
	);

	counter48 #(
		.DATASIZE(32)
	) sent_r_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(sent_r_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(sent_r_count)
	);

	counter48 #(
		.DATASIZE(32)
	) rcvd_rsp_count_I (
		.clk(clk),
		.res_n(res_n),
		.increment(rcvd_rsp_count_countup),
 		.load(32'b0),
		.load_enable(rreinit),
		.value(rcvd_rsp_count)
	);


	/* register status */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			status_link_up <= 1'h0;
			status_link_training <= 1'h0;
			status_descramblers_aligned <= 1'h0;
			status_sleep_mode <= 1'h0;
			status_lanes_reversed <= 1'h0;
			status_rsvd0 <= 3'h0;
			status_tx_init_NULL_1 <= 1'h0;
			status_tx_init_TS1 <= 1'h0;
			status_tx_init_NULL_2 <= 1'h0;
			status_hmc_init_TS1 <= 1'h0;
			status_hmc_init_NULL_2 <= 1'h0;
			status_hmc_init_TRET <= 1'h0;
			status_rsvd1 <= 2'h0;
			status_token_count <= 1'h0;
			status_rsvd2 <= 6'h0;
			status_lane_polarity_reversed <= 0;
			status_lane_descramblers_locked <= 0;
			status_phy_ready <= 1'h0;
		end
		else
		begin

				status_link_up <= status_link_up_next;
				status_link_training <= status_link_training_next;
				status_descramblers_aligned <= status_descramblers_aligned_next;
				status_sleep_mode <= status_sleep_mode_next;
				status_lanes_reversed <= status_lanes_reversed_next;
				status_tx_init_NULL_1 <= status_tx_init_NULL_1_next;
				status_tx_init_TS1 <= status_tx_init_TS1_next;
				status_tx_init_NULL_2 <= status_tx_init_NULL_2_next;
				status_hmc_init_TS1 <= status_hmc_init_TS1_next;
				status_hmc_init_NULL_2 <= status_hmc_init_NULL_2_next;
				status_hmc_init_TRET <= status_hmc_init_TRET_next;
				status_token_count <= status_token_count_next;
				status_lane_polarity_reversed <= status_lane_polarity_reversed_next;
				status_lane_descramblers_locked <= status_lane_descramblers_locked_next;
				status_phy_ready <= status_phy_ready_next;
		end
	end

	/* register control */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			control_put_hmc_in_sleep_mode <= 1'h0;
			control_scrambler_disable <= 1'h0;
			control_upper_lanes <= 1'h0;
			control_p_rst_n <= 1'h0;
			control_first_cube_ID <= 3'h0;
			control_rx_token_count <= 4;
			control_rsvd_control_2 <= 6'h0;
			control_bit_slip_time <= 8'h30;
			control_irtry_received_threshold <= 5'h10;
			control_irtry_to_send <= 5'h10;
		end
		else
		begin

			if((address[6:3]== 1) && write_en)
			begin
				control_put_hmc_in_sleep_mode <= write_data[0:0];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_scrambler_disable <= write_data[1:1];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_upper_lanes <= write_data[2:2];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_p_rst_n <= write_data[3:3];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_first_cube_ID <= write_data[6:4];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_rx_token_count <= write_data[16:7];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_bit_slip_time <= write_data[30:23];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_irtry_received_threshold <= write_data[35:31];
			end
			if((address[6:3]== 1) && write_en)
			begin
				control_irtry_to_send <= write_data[40:36];
			end
		end
	end

	/* register counter_reset */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			rreinit <= 1'b0;
		end
		else
		begin

			if((address[6:3]== 2) && write_en)
			begin
				rreinit <= 1'b1;
			end
			else
			begin
				rreinit <= 1'b0;
			end
		end
	end

	/* register link_retries */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register poisoned_packets */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register sent_np */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register sent_p */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register sent_r */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end

	/* register rcvd_rsp */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
		end
		else
		begin

		end
	end


	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			invalid_address <= 1'b0;
			access_complete <= 1'b0;
			`ifdef ASIC
			read_data   <= 64'b0;
			`endif

		end
		else
		begin

			casex(address[6:3])
				4'h0:
				begin
					read_data[0:0] <= status_link_up;
					read_data[1:1] <= status_link_training;
					read_data[2:2] <= status_descramblers_aligned;
					read_data[3:3] <= status_sleep_mode;
					read_data[4:4] <= status_lanes_reversed;
					read_data[7:5] <= status_rsvd0;
					read_data[8:8] <= status_tx_init_NULL_1;
					read_data[9:9] <= status_tx_init_TS1;
					read_data[10:10] <= status_tx_init_NULL_2;
					read_data[11:11] <= status_hmc_init_TS1;
					read_data[12:12] <= status_hmc_init_NULL_2;
					read_data[13:13] <= status_hmc_init_TRET;
					read_data[15:14] <= status_rsvd1;
					read_data[25:16] <= status_token_count;
					read_data[31:26] <= status_rsvd2;
					read_data[35:32] <= status_lane_polarity_reversed;
					read_data[39:36] <= status_lane_descramblers_locked;
					read_data[40:40] <= status_phy_ready;
					read_data[63:41] <= 23'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h1:
				begin
					read_data[0:0] <= control_put_hmc_in_sleep_mode;
					read_data[1:1] <= control_scrambler_disable;
					read_data[2:2] <= control_upper_lanes;
					read_data[3:3] <= control_p_rst_n;
					read_data[6:4] <= control_first_cube_ID;
					read_data[16:7] <= control_rx_token_count;
					read_data[22:17] <= control_rsvd_control_2;
					read_data[30:23] <= control_bit_slip_time;
					read_data[35:31] <= control_irtry_received_threshold;
					read_data[40:36] <= control_irtry_to_send;
					read_data[63:41] <= 23'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h2:
				begin
					read_data[63:0] <= 64'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h3:
				begin
					read_data[31:0] <= link_retries_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h4:
				begin
					read_data[31:0] <= poisoned_packets_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h5:
				begin
					read_data[31:0] <= sent_np_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h6:
				begin
					read_data[31:0] <= sent_p_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h7:
				begin
					read_data[31:0] <= sent_r_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				4'h8:
				begin
					read_data[31:0] <= rcvd_rsp_count;
					read_data[63:32] <= 32'b0;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				default:
				begin
					invalid_address <= read_en || write_en;
					access_complete <= read_en || write_en;
				end		
			endcase
		end
	end
endmodule