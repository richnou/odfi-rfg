
/* auto generated by RFG */
/*
info_rf info_rf_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
	.driver_version(),
	.node_id(),
	.node_guid(),
	.node_vpids());
*/
module info_rf
(
	///\defgroup sys
	///@{ 
	input wire res_n,
	input wire clk,
	///}@ 
	///\defgroup rw_if
	///@{ 
	input wire[3:3] address,
	output reg[63:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[63:0] write_data,
	///}@ 
	output reg[15:0] node_id;
	input wire[23:0] node_guid_next;
);

	reg[31:0] driver_version;
	reg[23:0] node_guid;
	reg[15:0] node_vpids;


	/* register driver */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			driver_version <= 0x12abcd;
		end
		else
		begin
		end
	end

	/* register node */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			node_id <= 0;
			node_guid <= 0x12abcd;
			node_vpids <= 0;
		end
		else
		begin
			node_guid <= node_guid_next;
			if((address[3:3]== 1) && write_en)
			begin
				node_id <= write_data[15:0];
			end
		end
	end


	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			invalid_address <= 1'b0;
			access_complete <= 1'b0;
			`ifdef ASIC
			read_data   <= 64'b0;
			`endif
		end
		else
		begin
			casex(address[3:3])
				1'b0:
				begin
					read_data[31:0] <= driver_version;
					read_data[63:32] <= 32'b0
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				1'b1:
				begin
					read_data[15:0] <= node_id;
					read_data[39:16] <= node_guid;
					read_data[55:40] <= node_vpids;
					read_data[63:56] <= 8'b0
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				default:
				begin
					invalid_address <= read_en || write_en;
					access_complete <= read_en || write_en;
				end		
			endcase
		end
	end
endmodule;