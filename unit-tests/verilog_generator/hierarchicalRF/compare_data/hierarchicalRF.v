

/* auto generated by RFG */
/* address map
subRF: base: 0x0 size: 24
G2_r1: base: 0x20 size: 8
G3_r2: base: 0x28 size: 8

*/
/* instantiation template
hierarchicalRF hierarchicalRF_I (
	.res_n(),
	.clk(),
	.address(),
	.read_data(),
	.invalid_address(),
	.access_complete(),
	.read_en(),
	.write_en(),
	.write_data(),
	.subRF_address(),
	.subRF_read_data(),
	.subRF_invalid_address(),
	.subRF_access_complete(),
	.subRF_read_en(),
	.subRF_write_en(),
	.subRF_write_data(),
	.G2_r1_f1_next(),
	.G2_r1_f1(),
	.G3_r2_f1_next(),
	.G3_r2_f1()
);
*/
module hierarchicalRF
(
	///\defgroup sys
	///@{ 
	input wire res_n,
	input wire clk,
	///}@ 
	///\defgroup rw_if
	///@{ 
	input wire[5:3] address,
	output reg[63:0] read_data,
	output reg invalid_address,
	output reg access_complete,
	input wire read_en,
	input wire write_en,
	input wire[63:0] write_data,
	///}@ 
	output reg[4:3] subRF_address,
	input wire[63:0] subRF_read_data,
	input wire subRF_invalid_address,
	input wire subRF_access_complete,
	output reg subRF_read_en,
	output reg subRF_write_en,
	output reg[63:0] subRF_write_data,
	input wire[63:0] G2_r1_f1_next,
	output reg[63:0] G2_r1_f1,
	input wire[63:0] G3_r2_f1_next,
	output reg[63:0] G3_r2_f1

);



	/* RegisterFile subRF*/
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			subRF_write_en <= 1'b0;
			subRF_read_en  <= 1'b0;
			`ifdef ASIC
			subRF_write_data <= 64'b0;
			subRF_address  <= 4'b0;
			`endif
		end
		else
		begin
			if(address[5:5] == 1'h0)
			begin
				subRF_address <= address[4:3];
			end
			if( (address[5:5] == 1'h0) && write_en)
			begin
				subRF_write_data <= write_data[63:0];
				subRF_write_en <= 1'b1;
			end
			else
			begin
				subRF_write_en <= 1'b0;
			end
			if( (address[5:5] == 1'h0) && read_en)
			begin
				subRF_read_en <= 1'b1;
			end
			else
			begin
				subRF_read_en <= 1'b0;
			end
		end
	end

	/* register r1 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			G2_r1_f1 <= 0;
		end
		else
		begin

			if((address[5:3]== 4) && write_en)
			begin
				G2_r1_f1 <= write_data[63:0];
			end
			else
			begin
				G2_r1_f1 <= G2_r1_f1_next;
			end
		end
	end

	/* register r2 */
	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			G3_r2_f1 <= 0;
		end
		else
		begin

			if((address[5:3]== 5) && write_en)
			begin
				G3_r2_f1 <= write_data[63:0];
			end
			else
			begin
				G3_r2_f1 <= G3_r2_f1_next;
			end
		end
	end


	`ifdef ASYNC_RES
	always @(posedge clk or negedge res_n) `else
	always @(posedge clk) `endif
	begin
		if (!res_n)
		begin
			invalid_address <= 1'b0;
			access_complete <= 1'b0;
			`ifdef ASIC
			read_data   <= 64'b0;
			`endif

		end
		else
		begin

			casex(address[5:3])
				{1'h0,2'bxx}:
				begin
					read_data <= subRF_read_data;
					invalid_address <= subRF_invalid_address;
					access_complete <= subRF_access_complete;
				end
				3'h4:
				begin
					read_data[63:0] <= G2_r1_f1;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				3'h5:
				begin
					read_data[63:0] <= G3_r2_f1;
					invalid_address <= 1'b0;
					access_complete <= write_en || read_en;
				end
				default:
				begin
					invalid_address <= read_en || write_en;
					access_complete <= read_en || write_en;
				end		
			endcase
		end
	end
endmodule