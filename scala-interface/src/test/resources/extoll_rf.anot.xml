<!DOCTYPE Whatever>
<regfile>
 <regroot _baseAddress="0x0" name="extoll_rf">
  <regroot _baseAddress="0x4000" _absoluteAddress="0x4000" name="info_rf">
   <reg64 _absoluteAddress="0x4000" name="driver">
    <hwreg width="32" sw="ro" reset="32'd17484" name="ver" hw=""/>
   </reg64>
   <reg64 _absoluteAddress="0x4008" name="node">
    <hwreg width="24" sw="ro" reset="24'hABCD1A" name="guid" hw="wo"/>
    <hwreg width="16" sw="rw" reset="16'hADFE" name="id" hw="ro"/>
    <hwreg width="16" sw="ro" reset="256" name="vpids" hw=""/>
   </reg64>
   <reg64 _absoluteAddress="0x4010" name="management_sw">
    <hwreg width="32" desc="IP address of the backend process that started the latest enumeration" sw="rw" reset="32'h0" name="cfg_ip" hw=""/>
    <hwreg width="8" desc="Count that specifies the latest enumeration attempt that reached this node" sw="rw" reset="8'h0" name="enum_cnt" hw=""/>
    <hwreg width="8" desc="Count that specifies the latest configuration attempt that reached this node" sw="rw" reset="8'h0" name="cfg_count" hw=""/>
    <reserved width="15"/>
    <hwreg width="1" desc="This bit is set on nodes that currently have a backend enumeration or configuration attempt running" sw="rw" reset="1'h0" name="backend" hw=""/>
   </reg64>
   <reg64 desc="This register holds the primary IP address of the node as well as the IP address given to the EXTOLL interface (if any). Both registers are initialized by node system software." _absoluteAddress="0x4018" name="ip_addresses">
    <hwreg width="32" desc="Primary IP address of the node (in network byte order). It can be used to get the hostname of the node using a reverse DNS lookup" sw="rw" reset="32'h0" name="primary_ip_address" hw=""/>
    <hwreg width="32" desc="IP address of the EXTOLL interface (in network byte order). Usefull for ARP implementation over EXTOLL." sw="rw" reset="32'h0" name="extoll_ip_address" hw=""/>
   </reg64>
   <reg64 desc="This register should be set by system software and give directions to find the primary management entity in the system." _absoluteAddress="0x4020" name="mgt_ip_addresses">
    <hwreg width="32" desc="The EXTOLL Node ID of the primary management ID for this node." sw="rw" reset="32'h0" name="primary_mgt_ip_address" hw=""/>
    <hwreg width="32" desc="The IP Address of the primary management ID for this node." sw="rw" reset="32'h0" name="extoll_mgt_ip_address" hw=""/>
   </reg64>
   <reg64 desc="This register implements the EXTOLL time stamp counter (TSC). The counter is incremented at every clock cycle. A software write to the register loads the counter with the given value. In addition, the counter can be set from the global interrupt hardware to implement a globally sychronized time source." _absoluteAddress="0x4028" name="tsc">
    <hwreg width="48" sw="rw" counter="1" name="tsc" hw="rw"/>
   </reg64>
   <reg64 desc="This register specifies the value the TSC register will be loaded with, in case of an global interrupt." _absoluteAddress="0x4030" name="tsc_global_load_value">
    <hwreg width="48" sw="rw" reset="48'b0" name="tsc_data" hw="ro"/>
   </reg64>
   <repeat _iterSize="0x8" loop="8" _absoluteAddress="0x4038" name="scratchpad">
    <reg64 desc="This register is one entry of the 64 byte scratchpad space offered by EXTOLL." _offset="0x0" name="scratchpad">
     <hwreg width="64" desc="Scratchpad data." sw="rw" reset="64'h0" name="data" hw=""/>
    </reg64>
   </repeat>
   <reg64 desc="Enable/Disable TSC loading from the 4 global interrupt sources and control re-init of the timer interrupt logic from global interrupts" _absoluteAddress="0x4078" name="tsc_global_load_enable">
    <hwreg width="1" desc="Enable global interrupt 0 to load the tsc with the value from the tsc_global_load_value register" sw="rw" reset="1'b0" name="tsc_load_en_irq0" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 1 to load the tsc with the value from the tsc_global_load_value register" sw="rw" reset="1'b0" name="tsc_load_en_irq1" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 2 to load the tsc with the value from the tsc_global_load_value register" sw="rw" reset="1'b0" name="tsc_load_en_irq2" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 3 to load the tsc with the value from the tsc_global_load_value register" sw="rw" reset="1'b0" name="tsc_load_en_irq3" hw="ro"/>
    <reserved width="4"/>
    <hwreg width="1" desc="Enable global interrupt 0 to reinit the timer register (see timer_interrupt)" sw="rw" reset="1'b0" name="global_irq_reinit_en0" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 0 to reinit the timer register (see timer_interrupt)" sw="rw" reset="1'b0" name="global_irq_reinit_en1" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 0 to reinit the timer register (see timer_interrupt)" sw="rw" reset="1'b0" name="global_irq_reinit_en2" hw="ro"/>
    <hwreg width="1" desc="Enable global interrupt 0 to reinit the timer register (see timer_interrupt)" sw="rw" reset="1'b0" name="global_irq_reinit_en3" hw="ro"/>
   </reg64>
   <reg64 desc="Control the integrated timer." _absoluteAddress="0x4080" name="timer_interrupt">
    <hwreg width="48" desc="The period of the timer in clock cycles. Timer will count down from this value to zero and fire." sw="rw" reset="48'b0" name="timer_interrupt_period" hw="ro"/>
    <hwreg width="1" desc="Set this bit to one to enable the logic. Will be reset to 0 if a one-shot has occured." sw="rw" reset="1'b0" name="timer_interrupt_enable" hw="rw"/>
    <hwreg width="1" desc="Set this bit to one, to run timer logic in one-shot logic, i.e. once an interrupt has fired wait. &#xa;           Otherwise logic will run in recurring mode and fire again after period cycles." sw="rw" reset="1'b0" name="timer_interrupt_one_shot" hw="ro"/>
    <reserved width="6"/>
    <hwreg width="1" desc="Toggles everytime an interrupt is fired." sw="ro" reset="1'b0" name="timer_interrupt_toggle" hw="wo"/>
   </reg64>
  </regroot>
  <regroot _baseAddress="0x4800" _absoluteAddress="0x4800" name="i2c_rf">
   <reg64 desc="Contains the command and data to be written or read to the I2C Bus" _absoluteAddress="0x4800" name="i2c">
    <hwreg width="32" desc="Contains the data that should be written or have been read" sw="rw" reset="32'h0" name="data" hw="rw"/>
    <hwreg width="1" desc="Specifies whether if it shall be written to or read from the device, 0 = write, 1 = read" sw="rw" reset="1'h0" name="read_write" hw="ro"/>
    <hwreg width="7" desc="Contains the Slave Device Address" sw="rw" reset="7'h0" name="slave_addr" hw="ro"/>
    <hwreg width="8" desc="Specifies the Byte Address to or from which shall be written / read" sw="rw" reset="8'h0" name="byte_addr" hw="ro"/>
    <hwreg width="3" desc="Specifies how many bytes shall be written or read, maximum number is 4 (due to 32bit data register)" sw="rw" reset="3'h0" name="byte_count" hw="ro"/>
    <hwreg width="1" desc="Selects the I2C interface which shall be used, 1'b0 = Si570, 1'b1 = I2C Switch" sw="rw" reset="1'h0" name="interface_sel" hw="ro"/>
    <hwreg width="1" desc="Indicates that the current command still needs to be processed, has to be set to 1 by SW" sw="rw" reset="1'h0" name="cmd_valid" hw="ro"/>
    <hwreg width="2" desc="Tells the software that the command has been completed. The value 2'b01 means success, 2'b11 failed. In case of an read command, this also is the data valid indicator. This register needs to be cleared by SW" sw="rw" reset="2'h0" name="cmd_complete" hw="wo"/>
    <hwreg width="1" desc="Selects whether to send byte address or not, 1'b0 = send byte address, 1'b1 = don't send byte address" sw="rw" reset="1'h0" name="send_byte_address_n" hw="ro"/>
   </reg64>
   <reg64 desc="Contains the command and data to be written or read to the I2C Bus" _absoluteAddress="0x4808" name="si570">
    <hwreg width="3" desc="Contains the hs_div value read from the si570 device" sw="ro" reset="3'h0" name="hs_div" hw="wo"/>
    <hwreg width="38" desc="Contains the rfreq value read from the si570 device" sw="ro" reset="38'h0" name="rfreq" hw="wo"/>
    <hwreg width="7" desc="Contains the n1 value read from the si570 device" sw="ro" reset="7'h0" name="n1" hw="wo"/>
    <hwreg width="1" desc="Indicator that the values read are valid, if 0 something went wrong" sw="ro" reset="1'h0" name="valid" hw="wo"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0x4810" name="rsvd0">
    <hwreg width="64" sw="ro" reset="64'h0" name="rsvd0" hw="wo"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0x4818" name="rsvd1">
    <hwreg width="64" sw="ro" reset="64'h0" name="rsvd1" hw="wo"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0x4820" name="config">
    <hwreg width="1" desc=" Ignore I2C Acknowledges in the master." sw="rw" reset="1'h0" name="ignore_ack" hw="ro"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0x4828" name="sysmon">
    <hwreg width="3" desc="Alarms provided by system monitor: [0] = temperature-sensor alarm, [1] = VCCINT-sensor alarm, [2] = VCCAUX-sensor alarm" sw="ro" reset="3'h0" name="alarms" hw="wo"/>
    <hwreg width="1" desc="Over-temperature alarm provided by system monitor." sw="ro" reset="1'h0" name="ot" hw="wo"/>
   </reg64>
   <ramblock addrsize="7" ramwidth="16" sw="rw" _absoluteAddress="0x4c00" name="sysmon_interface" external="1" hw="ro"/>
  </regroot>
  <regroot _baseAddress="0x5000" _absoluteAddress="0x5000" name="pflash_rf">
   <reg64 _absoluteAddress="0x5000" name="ctrl">
    <hwreg width="1" desc="Command: Buffer Program (Write 32 Words)" sw="rw" reset="1'h0" name="buffer_program" hw="rw"/>
    <hwreg width="1" desc="Command: Single Word Program (Write a word)" sw="rw" reset="1'h0" name="word_program" hw="rw"/>
    <hwreg width="1" desc="Command: Buffer Read (Reads 32 Words)" sw="rw" reset="1'h0" name="buffer_read" hw="rw"/>
    <hwreg width="1" desc="Command: Erase a block" sw="rw" reset="1'h0" name="erase_block" hw="rw"/>
    <hwreg width="1" desc="Command: Lock/Unlock a block" sw="rw" reset="1'h0" name="lock_unlock_block" hw="rw"/>
    <hwreg width="1" desc="Command: Read a single word, written to buffer_data[0]" sw="rw" reset="1'h0" name="read_word" hw="rw"/>
    <hwreg width="1" desc="Command: Writes a single word from Address and buffer_data[0]" sw="rw" reset="1'h0" name="program_word" hw="rw"/>
    <hwreg width="1" desc="Command: Clears the status register" sw="rw" reset="1'h0" name="clear_status_register" hw="rw"/>
    <hwreg width="1" desc="Command: Reads the electronic signature of block" sw="rw" reset="1'h0" name="read_electronic_signature" hw="rw"/>
    <hwreg width="8" desc="Unused for the moment. Some kind of status given by software" sw="rw" reset="4'h0" name="sw_status" hw="ro"/>
    <hwreg width="8" desc="Reports errors from hardware. Synced to flash status register." sw="ro" reset="4'h0" name="hw_status" hw="rw"/>
   </reg64>
   <reg64 _absoluteAddress="0x5008" name="base_addr">
    <hwreg width="23" desc="Address to start Buffer Program or Buffer Read operations" sw="rw" reset="23'h000000" name="base_addr" hw="ro"/>
   </reg64>
   <ramblock addrsize="5" ramwidth="16" sw="rw" _absoluteAddress="0x5100" name="buffer_data" external="0" hw="rw"/>
  </regroot>
  <regroot _baseAddress="0x5200" _absoluteAddress="0x5200" name="htax_bridge_rf">
   <repeat _iterSize="0x18" loop="5" _absoluteAddress="0x5200" name="intvl">
    <reg64 desc="contains upper bound of address (page aligned, last 12 bit missing) for current interval, the address check is smaller than so write next larger page address" _offset="0x0" name="upper">
     <hwreg width="36" desc="" sw="rw" reset="36'b0" name="bound" hw="ro"/>
    </reg64>
    <reg64 desc="contains lower bound of address (page aligned, last 12 bit missing) for current interval, the address check is larger than so write next smaller page address" _offset="0x8" name="lower">
     <hwreg width="36" desc="" sw="rw" reset="36'b0" name="bound" hw="ro"/>
    </reg64>
    <reg64 desc="" _offset="0x10" name="control">
     <hwreg width="1" desc="Enables routing for current interval" sw="rw" reset="1'h0" name="enable" hw="ro"/>
     <hwreg width="4" desc="contains the value that is written into the HTOC target port field for this interval" sw="rw" reset="4'b0" name="port" hw="ro"/>
     <hwreg width="9" desc="contains target port for current interval in one-hot encoding" sw="rw" reset="9'b0" name="port_oh" hw="ro"/>
     <hwreg width="3" desc="contains the allowed VCs for this interval in one-hot encoding" sw="rw" reset="3'b0" name="vcs" hw="ro"/>
    </reg64>
   </repeat>
   <reg64 desc="" _absoluteAddress="0x5278" name="general">
    <hwreg width="4" desc="Default Port where unmatched packets are forwarded to in binary encoding" sw="rw" reset="4'b0" name="default_port" hw="ro"/>
    <hwreg width="9" desc="Default Port where unmatched packets are forwarded to in one-hot encoding" sw="rw" reset="9'b0" name="default_port_oh" hw="ro"/>
    <hwreg width="1" desc="Mask error responses (clears the error bit)" sw="rw" reset="1'h0" name="mask_error_bit" hw="ro"/>
    <hwreg width="1" desc="Enables Store and Forward Mode in HTAX bridge, default is cut-through mode (=0)" sw="rw" reset="1'h0" name="use_sf_mode" hw="ro"/>
    <hwreg width="1" desc="Enables Interval routing" sw="rw" reset="1'b0" name="enable" hw="ro"/>
    <hwreg width="1" desc="Enables HT-Core EMMIO feature for BAR2." sw="rw" reset="1'b0" name="enable_emmio" hw="ro"/>
   </reg64>
   <reg64 desc="Debugging information for the HTAX Bridge" _absoluteAddress="0x5280" name="debug">
    <hwreg width="1" desc="Posted Command FIFO to the HT-Core is full" sw="ro" reset="1'h0" name="p_app2core_full" hw="wo"/>
    <hwreg width="1" desc="Non-Posted Posted Command FIFO to the HT-Core is full" sw="ro" reset="1'h0" name="np_app2core_full" hw="wo"/>
    <hwreg width="1" desc="Response Command FIFO to the HT-Core is full" sw="ro" reset="1'h0" name="r_app2core_full" hw="wo"/>
    <hwreg width="1" desc="Posted Command FIFO from the HT-Core is empty" sw="ro" reset="1'h0" name="p_core2app_empty" hw="wo"/>
    <hwreg width="1" desc="Non-Posted Command FIFO from the HT-Core is empty" sw="ro" reset="1'h0" name="np_core2app_empty" hw="wo"/>
    <hwreg width="1" desc="Response Command FIFO from the HT-Core is empty" sw="ro" reset="1'h0" name="r_core2app_empty" hw="wo"/>
    <hwreg width="1" desc="There are no source tags left in the HT-Core if this bit is set" sw="ro" reset="1'h0" name="source_tags_depleted" hw="wo"/>
    <hwreg width="3" desc="Indicates that a CMD has been shifted into a full FIFO" sw="ro" reset="3'h0" name="cmd_full_assertion" hw="wo"/>
    <hwreg width="3" desc="Indicates that CMD Shift-in has been asserted for more than one contiguous cycle" sw="ro" reset="3'h0" name="cmd_si_assertion" hw="wo"/>
    <hwreg width="3" desc="Indicates that a data has been shifted into a full FIFO" sw="ro" reset="3'h0" name="d_full_assertion" hw="wo"/>
    <hwreg width="3" desc="Indicates that the HT_COUNT field does not match the data_count shifted into the data Fifo" sw="ro" reset="3'h0" name="count_assertion" hw="wo"/>
    <hwreg width="5" desc="State of Posted htax2cores FSM" sw="ro" reset="5'h0" name="p_htax2cores_state" hw="wo"/>
    <hwreg width="5" desc="State of Non-Posted htax2cores FSM" sw="ro" reset="5'h0" name="np_htax2cores_state" hw="wo"/>
    <hwreg width="5" desc="State of Response htax2cores FSM" sw="ro" reset="5'h0" name="r_htax2cores_state" hw="wo"/>
    <hwreg width="3" desc="State of Posted cores2htax FSM" sw="ro" reset="3'h0" name="p_cores2htax_state" hw="wo"/>
    <hwreg width="3" desc="State of Non-Posted cores2htax FSM" sw="ro" reset="3'h0" name="np_cores2htax_state" hw="wo"/>
    <hwreg width="3" desc="State of Response cores2htax FSM" sw="ro" reset="3'h0" name="r_cores2htax_state" hw="wo"/>
    <hwreg width="7" desc="Input of Posted cores2htax FSM" sw="ro" reset="7'h0" name="p_cores2htax_input" hw="wo"/>
    <hwreg width="7" desc="Input of Non-Posted cores2htax FSM" sw="ro" reset="7'h0" name="np_cores2htax_input" hw="wo"/>
    <hwreg width="7" desc="Input of Response cores2htax FSM" sw="ro" reset="7'h0" name="r_cores2htax_input" hw="wo"/>
   </reg64>
   <reg64 desc="This register that holds counter fields for received and sent packets" _absoluteAddress="0x5288" name="posted_counter">
    <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields for received and sent packets" _absoluteAddress="0x5290" name="nonposted_counter">
    <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields for received and sent packets" _absoluteAddress="0x5298" name="response_counter">
    <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields for discarded packets" _absoluteAddress="0x52a0" name="discarded_counter">
    <hwreg width="16" sw="rw" counter="1" name="posted" hw=""/>
    <hwreg width="16" sw="rw" counter="1" name="nonposted" hw=""/>
    <hwreg width="16" sw="rw" counter="1" name="response" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields for discarded packets" _absoluteAddress="0x52a8" name="error_ecc">
    <hwreg width="1" desc="A single bit error was corrected inside the tagmap used only during HT operation." sw="rw" reset="1'b0" name="tagmap_sec" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the tagmap used only during HT operation." sw="rw" reset="1'b0" name="tagmap_ded" hw="wo"/>
   </reg64>
  </regroot>
  <regroot _baseAddress="0x5300" _absoluteAddress="0x5300" name="htax_rf">
   <reg64 desc="Some Assertions for the HTAX, each bit in the fields represent one port" _absoluteAddress="0x5300" name="debug_0">
    <hwreg width="9" desc="indicates that two SOTs have been seen without EOT in between - sent from HTAX to FU" sw="ro" reset="9'b0" name="rx_sot_eot_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that two SOTs have been seen without EOT in between - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_sot_eot_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that two SOTs have been seen without Release Grant in between - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_sot_rg_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that SOT and EOT have been asserted in the same cycle. This only applies to the FPGA (64 bit) version and is not possible in the ASIC (128 bit) version - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_sot_same_as_eot_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that a Gap between Release Grant and EOT occured - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_rg_eot_gap_assertion" hw="wo"/>
   </reg64>
   <reg64 desc="Some Assertions for the HTAX, each bit in the fields represent one port" _absoluteAddress="0x5308" name="debug_1">
    <hwreg width="9" desc="indicates that EOT has been asserted for more than one cycle - sent from HTAX to FU" sw="ro" reset="9'b0" name="rx_eot_pulse_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that SOT has been asserted for more than one cycle - sent from HTAX to FU" sw="ro" reset="9'b0" name="rx_sot_pulse_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that EOT has been asserted for more than one cycle - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_eot_pulse_assertion" hw="wo"/>
    <hwreg width="9" desc="indicates that Release Grant has been asserted for more than one cycle - sent from FU to HTAX" sw="ro" reset="9'b0" name="tx_rg_pulse_assertion" hw="wo"/>
   </reg64>
   <reg64 desc="Some Assertions for the HTAX, each bit in the fields represent one port" _absoluteAddress="0x5310" name="debug_2">
    <hwreg width="9" desc="indicates that a grant has been given but not yet been returned. Set when vc_grant | vc_request is set and cleared when an EOT is observed - traffic direction is HTAX to FU" sw="ro" reset="9'b0" name="rx_gnt_active" hw="wo"/>
    <hwreg width="9" desc="indicates that a packet is active on the port. Set when vc_grant and an SOT was seen and cleared when an EOT is observed - traffic direction is HTAX to FU" sw="ro" reset="9'b0" name="rx_packet_active" hw="wo"/>
    <hwreg width="9" desc="indicates that a grant has been given but not yet been returned. Set when vc_grant is set and cleared when release_grant was seen - traffic direction is FU to HTAX" sw="ro" reset="9'b0" name="tx_gnt_active" hw="wo"/>
    <hwreg width="9" desc="indicates that a packet is active on the port. Set when vc_grant and an SOT was seen and cleared when EOT is observed - traffic direction is FU to HTAX" sw="ro" reset="9'b0" name="tx_packet_active" hw="wo"/>
   </reg64>
   <repeat _iterSize="0x8" loop="9" _absoluteAddress="0x5318" name="port">
    <reg64 desc="Current request/grant signals of the RX interface of this HTAX port. Note that these are mainly intended to debug stuck conditions as sampling them during operation does seem meaningful." _offset="0x0" name="debug">
     <hwreg width="3" desc="The VC request signal of this port's RX interface." sw="ro" reset="3'b0" name="rx_vc_req" hw="wo"/>
     <hwreg width="3" desc="The VC grant signal of this port's RX interface." sw="ro" reset="3'b0" name="rx_vc_gnt" hw="wo"/>
     <hwreg width="3" desc="The VC request signal of this port's TX interface." sw="ro" reset="3'b0" name="tx_vc_req" hw="wo"/>
     <hwreg width="3" desc="The VC grant signal of this port's TX interface." sw="ro" reset="3'b0" name="tx_vc_gnt" hw="wo"/>
     <hwreg width="9" desc="The Port request signal of this port's TX interface." sw="ro" reset="9'b0" name="tx_port_req" hw="wo"/>
    </reg64>
   </repeat>
  </regroot>
  <regroot _baseAddress="0x5400" _absoluteAddress="0x5400" name="np_top_rf">
   <regroot _baseAddress="0x5400" _absoluteAddress="0x5400" name="n0">
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP HP2NP side" _absoluteAddress="0x5400" name="hp2np_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP NP2HP side" _absoluteAddress="0x5408" name="np2hp_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x5410" name="np_debug_0">
     <hwreg width="36" desc="Holds the used credit count values for all FCCs: current counter values for each FCC" sw="ro" reset="36'b0" name="fcc_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="Debug and Control registers for Crossbar Outport" _absoluteAddress="0x5418" name="general">
     <hwreg width="1" desc="Enables send functionality for the NP. RAW interface is activated if enable is set to 0." sw="rw" reset="1'h0" name="enable" hw="ro"/>
     <hwreg width="6" desc="This register determines how many words are required for a flit to be injected into the network. This register directly controls latency, the number indicated in this register is added as additional latency." sw="rw" reset="6'h1f" name="utilization" hw="ro"/>
     <hwreg width="1" desc="This register sets the desired receive mode. 0 stands for Cut-Through, 1 for Store-and-Forward" sw="rw" reset="1'h1" name="recv_mode" hw="ro"/>
     <hwreg width="1" desc="Shows the empty signal of the NP receive buffer." sw="ro" reset="1'h0" name="empty" hw="wo"/>
     <hwreg width="1" desc="Shows that np is idle and disabled." sw="ro" reset="1'h0" name="disabled" hw="wo"/>
     <hwreg width="1" desc="Shows the full signal of the NP send buffer." sw="ro" reset="1'h0" name="full" hw="wo"/>
     <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x5420" name="credits_0">
     <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
     <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x5428" name="credits_1">
     <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
     <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
     <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
     <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
     <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
    </reg64>
    <reg64 desc="Control and Debug for Crossbar Outport" _absoluteAddress="0x5430" name="avail_fcc">
     <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="rw" reset="6'b111111" name="mask" hw="ro"/>
    </reg64>
    <reg64 desc="RAW interface to inject packets" _absoluteAddress="0x5438" name="raw_ctrl">
     <hwreg width="1" desc="RAW control register. Should be written last. Data will be injected once this register is written." sw="rw" reset="1'b0" name="sop" hw="ro"/>
     <hwreg width="1" desc="RAW control register. {eop_lane_[NUM_LANES-1]...eop_lane_0}" sw="rw" reset="`NUM_LANES'b0" name="eop" hw="ro"/>
    </reg64>
    <repeat _iterSize="0x8" loop="1" _absoluteAddress="0x5440" name="ln">
     <reg64 desc="RAW interface to inject packets" _offset="0x0" name="raw">
      <hwreg width="64" desc="RAW data for lane 0. SW can send data packets using this register." sw="rw" reset="64'h0" name="data" hw="ro"/>
     </reg64>
    </repeat>
    <reg64 desc="SEC/DED for NP Rams" _absoluteAddress="0x5448" name="np_debug_1">
     <hwreg width="1" desc="Double error deteced in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
   <regroot _baseAddress="0x5480" _absoluteAddress="0x5480" name="n1">
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP HP2NP side" _absoluteAddress="0x5480" name="hp2np_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP NP2HP side" _absoluteAddress="0x5488" name="np2hp_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x5490" name="np_debug_0">
     <hwreg width="36" desc="Holds the used credit count values for all FCCs: current counter values for each FCC" sw="ro" reset="36'b0" name="fcc_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="Debug and Control registers for Crossbar Outport" _absoluteAddress="0x5498" name="general">
     <hwreg width="1" desc="Enables send functionality for the NP. RAW interface is activated if enable is set to 0." sw="rw" reset="1'h0" name="enable" hw="ro"/>
     <hwreg width="6" desc="This register determines how many words are required for a flit to be injected into the network. This register directly controls latency, the number indicated in this register is added as additional latency." sw="rw" reset="6'h1f" name="utilization" hw="ro"/>
     <hwreg width="1" desc="This register sets the desired receive mode. 0 stands for Cut-Through, 1 for Store-and-Forward" sw="rw" reset="1'h1" name="recv_mode" hw="ro"/>
     <hwreg width="1" desc="Shows the empty signal of the NP receive buffer." sw="ro" reset="1'h0" name="empty" hw="wo"/>
     <hwreg width="1" desc="Shows that np is idle and disabled." sw="ro" reset="1'h0" name="disabled" hw="wo"/>
     <hwreg width="1" desc="Shows the full signal of the NP send buffer." sw="ro" reset="1'h0" name="full" hw="wo"/>
     <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x54a0" name="credits_0">
     <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
     <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x54a8" name="credits_1">
     <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
     <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
     <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
     <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
     <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
    </reg64>
    <reg64 desc="Control and Debug for Crossbar Outport" _absoluteAddress="0x54b0" name="avail_fcc">
     <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="rw" reset="6'b111111" name="mask" hw="ro"/>
    </reg64>
    <reg64 desc="RAW interface to inject packets" _absoluteAddress="0x54b8" name="raw_ctrl">
     <hwreg width="1" desc="RAW control register. Should be written last. Data will be injected once this register is written." sw="rw" reset="1'b0" name="sop" hw="ro"/>
     <hwreg width="1" desc="RAW control register. {eop_lane_[NUM_LANES-1]...eop_lane_0}" sw="rw" reset="`NUM_LANES'b0" name="eop" hw="ro"/>
    </reg64>
    <repeat _iterSize="0x8" loop="1" _absoluteAddress="0x54c0" name="ln">
     <reg64 desc="RAW interface to inject packets" _offset="0x0" name="raw">
      <hwreg width="64" desc="RAW data for lane 0. SW can send data packets using this register." sw="rw" reset="64'h0" name="data" hw="ro"/>
     </reg64>
    </repeat>
    <reg64 desc="SEC/DED for NP Rams" _absoluteAddress="0x54c8" name="np_debug_1">
     <hwreg width="1" desc="Double error deteced in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
   <regroot _baseAddress="0x5500" _absoluteAddress="0x5500" name="n2">
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP HP2NP side" _absoluteAddress="0x5500" name="hp2np_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP NP2HP side" _absoluteAddress="0x5508" name="np2hp_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x5510" name="np_debug_0">
     <hwreg width="36" desc="Holds the used credit count values for all FCCs: current counter values for each FCC" sw="ro" reset="36'b0" name="fcc_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="Debug and Control registers for Crossbar Outport" _absoluteAddress="0x5518" name="general">
     <hwreg width="1" desc="Enables send functionality for the NP. RAW interface is activated if enable is set to 0." sw="rw" reset="1'h0" name="enable" hw="ro"/>
     <hwreg width="6" desc="This register determines how many words are required for a flit to be injected into the network. This register directly controls latency, the number indicated in this register is added as additional latency." sw="rw" reset="6'h1f" name="utilization" hw="ro"/>
     <hwreg width="1" desc="This register sets the desired receive mode. 0 stands for Cut-Through, 1 for Store-and-Forward" sw="rw" reset="1'h1" name="recv_mode" hw="ro"/>
     <hwreg width="1" desc="Shows the empty signal of the NP receive buffer." sw="ro" reset="1'h0" name="empty" hw="wo"/>
     <hwreg width="1" desc="Shows that np is idle and disabled." sw="ro" reset="1'h0" name="disabled" hw="wo"/>
     <hwreg width="1" desc="Shows the full signal of the NP send buffer." sw="ro" reset="1'h0" name="full" hw="wo"/>
     <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x5520" name="credits_0">
     <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
     <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x5528" name="credits_1">
     <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
     <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
     <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
     <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
     <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
    </reg64>
    <reg64 desc="Control and Debug for Crossbar Outport" _absoluteAddress="0x5530" name="avail_fcc">
     <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="rw" reset="6'b111111" name="mask" hw="ro"/>
    </reg64>
    <reg64 desc="RAW interface to inject packets" _absoluteAddress="0x5538" name="raw_ctrl">
     <hwreg width="1" desc="RAW control register. Should be written last. Data will be injected once this register is written." sw="rw" reset="1'b0" name="sop" hw="ro"/>
     <hwreg width="1" desc="RAW control register. {eop_lane_[NUM_LANES-1]...eop_lane_0}" sw="rw" reset="`NUM_LANES'b0" name="eop" hw="ro"/>
    </reg64>
    <repeat _iterSize="0x8" loop="1" _absoluteAddress="0x5540" name="ln">
     <reg64 desc="RAW interface to inject packets" _offset="0x0" name="raw">
      <hwreg width="64" desc="RAW data for lane 0. SW can send data packets using this register." sw="rw" reset="64'h0" name="data" hw="ro"/>
     </reg64>
    </repeat>
    <reg64 desc="SEC/DED for NP Rams" _absoluteAddress="0x5548" name="np_debug_1">
     <hwreg width="1" desc="Double error deteced in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
   <regroot _baseAddress="0x5580" _absoluteAddress="0x5580" name="n3">
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP HP2NP side" _absoluteAddress="0x5580" name="hp2np_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="This register that holds counter fields for received and sent packets for the NP NP2HP side" _absoluteAddress="0x5588" name="np2hp_counter">
     <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
    </reg64>
    <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x5590" name="np_debug_0">
     <hwreg width="36" desc="Holds the used credit count values for all FCCs: current counter values for each FCC" sw="ro" reset="36'b0" name="fcc_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="Debug and Control registers for Crossbar Outport" _absoluteAddress="0x5598" name="general">
     <hwreg width="1" desc="Enables send functionality for the NP. RAW interface is activated if enable is set to 0." sw="rw" reset="1'h0" name="enable" hw="ro"/>
     <hwreg width="6" desc="This register determines how many words are required for a flit to be injected into the network. This register directly controls latency, the number indicated in this register is added as additional latency." sw="rw" reset="6'h1f" name="utilization" hw="ro"/>
     <hwreg width="1" desc="This register sets the desired receive mode. 0 stands for Cut-Through, 1 for Store-and-Forward" sw="rw" reset="1'h1" name="recv_mode" hw="ro"/>
     <hwreg width="1" desc="Shows the empty signal of the NP receive buffer." sw="ro" reset="1'h0" name="empty" hw="wo"/>
     <hwreg width="1" desc="Shows that np is idle and disabled." sw="ro" reset="1'h0" name="disabled" hw="wo"/>
     <hwreg width="1" desc="Shows the full signal of the NP send buffer." sw="ro" reset="1'h0" name="full" hw="wo"/>
     <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
    </reg64>
    <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x55a0" name="credits_0">
     <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
     <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x55a8" name="credits_1">
     <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
     <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
     <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
     <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
     <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
    </reg64>
    <reg64 desc="Control and Debug for Crossbar Outport" _absoluteAddress="0x55b0" name="avail_fcc">
     <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="rw" reset="6'b111111" name="mask" hw="ro"/>
    </reg64>
    <reg64 desc="RAW interface to inject packets" _absoluteAddress="0x55b8" name="raw_ctrl">
     <hwreg width="1" desc="RAW control register. Should be written last. Data will be injected once this register is written." sw="rw" reset="1'b0" name="sop" hw="ro"/>
     <hwreg width="1" desc="RAW control register. {eop_lane_[NUM_LANES-1]...eop_lane_0}" sw="rw" reset="`NUM_LANES'b0" name="eop" hw="ro"/>
    </reg64>
    <repeat _iterSize="0x8" loop="1" _absoluteAddress="0x55c0" name="ln">
     <reg64 desc="RAW interface to inject packets" _offset="0x0" name="raw">
      <hwreg width="64" desc="RAW data for lane 0. SW can send data packets using this register." sw="rw" reset="64'h0" name="data" hw="ro"/>
     </reg64>
    </repeat>
    <reg64 desc="SEC/DED for NP Rams" _absoluteAddress="0x55c8" name="np_debug_1">
     <hwreg width="1" desc="Double error deteced in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP sender FIFO." sw="rw" reset="1'b0" name="np_sender_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver FIFO." sw="rw" reset="1'b0" name="np_receiver_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in NP receiver credit FIFO." sw="rw" reset="1'b0" name="np_credit_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
  </regroot>
  <regroot _baseAddress="0x5800" _absoluteAddress="0x5800" name="smfu_rf">
   <reg64 desc="SMFU status and control" _absoluteAddress="0x5800" name="status_control">
    <hwreg width="1" desc="enable/disable SMFU" sw="rw" reset="1'h0" name="EN" hw="ro"/>
    <hwreg width="1" desc="address calculation ready" sw="ro" reset="1'h0" name="ACR" hw="wo"/>
    <hwreg width="1" desc="matching store empty, i.e. no nonposted requests outstanding" sw="ro" reset="1'h0" name="MSE" hw="wo"/>
    <hwreg width="1" desc="SMFU idle" sw="ro" reset="1'h0" name="IDL" hw="wo"/>
    <hwreg width="1" desc="RAM Single-bit Error Corrected" sw="rw" reset="1'h0" name="SEC" hw="wo"/>
    <hwreg width="1" desc="RAM Double-bit Error Detected" sw="rw" reset="1'h0" name="DED" hw="wo"/>
    <hwreg width="2" sw="ro" reset="2'h0" name="rsvd0" hw=""/>
    <hwreg width="1" desc="enable posted2nonposted translation, use mse to determine if requests are outstanding" sw="rw" reset="1'h0" name="enable_p2np" hw="ro"/>
    <hwreg width="1" desc="force passPW to be set for all outgoing nonposted requests" sw="rw" reset="1'h0" name="force_passPW" hw="ro"/>
   </reg64>
   <reg64 desc="Traffic Class Control" _absoluteAddress="0x5808" name="traffic_class">
    <hwreg width="2" desc="traffic class for nonposted requests" sw="rw" reset="2'h2" name="tc_np" hw="ro"/>
    <hwreg width="2" sw="ro" reset="2'h0" name="rsvd0" hw=""/>
    <hwreg width="2" desc="traffic class for posted requests" sw="rw" reset="2'h2" name="tc_p" hw="ro"/>
    <hwreg width="2" sw="ro" reset="2'h0" name="rsvd1" hw=""/>
    <hwreg width="2" desc="traffic class for responses" sw="rw" reset="2'h3" name="tc_rsp" hw="ro"/>
   </reg64>
   <reg64 desc="SMFU timeout" _absoluteAddress="0x5810" name="timeout_control">
    <hwreg width="24" desc="timeout value when an error response should be generated (for np requests)" sw="rw" reset="24'h100000" name="timeout" hw="ro"/>
    <hwreg width="8" sw="ro" reset="8'h0" name="rsvd0" hw=""/>
    <hwreg width="1" desc="timeout occurred, SMFU is in flush mode (consuming all requests)" sw="rw" reset="1'h0" name="timeout_ERR" hw="rw"/>
   </reg64>
   <reg64 desc="Reset performance counters" _absoluteAddress="0x5818" name="counter_reset">
    <hwreg width="1" sw="wo" reset="1'h0" name="counter_reset" hw=""/>
    <hwreg width="1" sw="ro" reset="1'h0" name="dummy" hw=""/>
    <rreinit/>
   </reg64>
   <reg64 desc="Nonposted requests sent to the network" _absoluteAddress="0x5820" name="sent_count_np">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Posted requests sent to the network" _absoluteAddress="0x5828" name="sent_count_p">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Responses sent to the network" _absoluteAddress="0x5830" name="sent_count_rsp">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Nonposted requests received from the network" _absoluteAddress="0x5838" name="rcvd_count_np">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Posted requests received from the network" _absoluteAddress="0x5840" name="rcvd_count_p">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Responses received from the network" _absoluteAddress="0x5848" name="rcvd_count_rsp">
    <hwreg width="48" sw="ro" counter="1" name="count" hw=""/>
   </reg64>
   <reg64 desc="Miscellaneous performance counters" _absoluteAddress="0x5850" name="misc_count">
    <hwreg width="32" desc="number of clock cycles between np sent to the host and any response received" sw="rw" reset="32'b0" name="np2r_clk_cycle_count" hw="rw"/>
    <hwreg width="1" sw="rw" reset="1'b0" name="overflow" hw="wo"/>
    <hwreg width="7" sw="ro" reset="7'h0" name="rsvd0" hw=""/>
    <hwreg width="10" desc="maximum number of concurrent outstanding requests" sw="rw" reset="10'b0" name="max_outstanding_nps" hw="rw"/>
   </reg64>
   <reg64 desc="Origin start address of the local aperture (mask-based)" _absoluteAddress="0x5858" name="oStartAddr">
    <hwreg width="48" sw="rw" reset="48'h0" name="oStartAddr" hw="ro"/>
   </reg64>
   <reg64 desc="Target start address of the exported memory region (mask-based)" _absoluteAddress="0x5860" name="tStartAddr_default">
    <hwreg width="48" sw="rw" reset="52'h0" name="tStartAddr_default" hw="ro"/>
   </reg64>
   <reg64 desc="Node offset to be added to the mask-based NodeID" _absoluteAddress="0x5868" name="nNodeOffset">
    <hwreg width="16" desc="Node offset to be added to the mask-based NodeID" sw="rw" reset="16'h0" name="nNodeOffset" hw="ro"/>
   </reg64>
   <reg64 desc="Mask for address translation (no interval hit)" _absoluteAddress="0x5870" name="addr_mask">
    <hwreg width="6" sw="ro" reset="6'h0" name="rsvd0" hw=""/>
    <hwreg width="42" desc="mask to be applied to the relative address (addr-oStartAddr)" sw="rw" reset="42'h0" name="mask" hw="ro"/>
    <hwreg width="16" sw="ro" reset="16'h0" name="rsvd1" hw=""/>
   </reg64>
   <reg64 desc="Padding" _absoluteAddress="0x5878" name="rsvd_0">
    <hwreg width="1" sw="" reset="1'b0" name="pad" hw=""/>
   </reg64>
   <repeat _iterSize="0x20" loop="16" _absoluteAddress="0x5880" name="interval">
    <reg64 desc="Defines address intervals to match addresses to NodeIDS (interval router)" _offset="0x0" name="control">
     <hwreg width="1" desc="enable this interval" sw="rw" reset="1'h0" name="Valid" hw="ro"/>
     <hwreg width="7" sw="ro" reset="7'h0" name="rsvd0" hw=""/>
     <hwreg width="3" desc="FuncNo to be set in the request" sw="rw" reset="3'h0" name="FuncNo" hw="ro"/>
     <hwreg width="5" sw="ro" reset="5'h0" name="rsvd1" hw=""/>
     <hwreg width="16" desc="target NodeID associated with this interval" sw="rw" reset="16'h0" name="tNodeId" hw="ro"/>
    </reg64>
    <reg64 desc="Defines the 48-bit start address of an interval (absolute)" _offset="0x8" name="startaddr">
     <hwreg width="12" sw="ro" reset="12'h0" name="page_offset" hw=""/>
     <hwreg width="36" sw="rw" reset="36'h0" name="iStartAddr" hw="ro"/>
    </reg64>
    <reg64 desc="Defines the 48-bit end address of an interval (absolute)" _offset="0x10" name="endaddr">
     <hwreg width="12" sw="ro" reset="12'hfff" name="page_offset" hw=""/>
     <hwreg width="36" sw="rw" reset="36'h0" name="iEndAddr" hw="ro"/>
    </reg64>
    <reg64 desc="Counters for each interval" _offset="0x18" name="counter">
     <hwreg width="32" sw="ro" counter="1" name="sent_count_np" hw=""/>
     <hwreg width="32" sw="ro" counter="1" name="sent_count_p" hw=""/>
    </reg64>
   </repeat>
   <repeat _iterSize="0x8" loop="16" _absoluteAddress="0x5a80" name="vpid">
    <reg64 desc="48-bit Target start address of the exported memory region (one for each VPID)" _offset="0x0" name="tStartAddr">
     <hwreg width="12" sw="ro" reset="12'h0" name="page_offset" hw=""/>
     <hwreg width="36" sw="rw" reset="36'h0" name="addr" hw="ro"/>
    </reg64>
   </repeat>
  </regroot>
  <regroot _baseAddress="0x8000" _absoluteAddress="0x8000" name="atu_rf">
   <reg64 _absoluteAddress="0x8000" name="control">
    <hwreg width="1" desc="enables the ATU" sw="rw" reset="1'b0" name="enable" hw="ro"/>
   </reg64>
   <reg64 desc="This register is used to write control commands to the ATU." _absoluteAddress="0x8008" name="cmd_interface">
    <hwreg width="64" desc="control commands" sw="wo" reset="64'b0" name="cmd_interface" hw="ro"/>
   </reg64>
   <reg64 desc="This register holds a TLB hit and a TLB miss counter" _absoluteAddress="0x8010" name="cnt_0">
    <hwreg width="32" desc="Counts how many translations were answered" sw="rw" counter="1" name="translations" hw=""/>
    <hwreg width="32" desc="Counts how many reads to the main memory were performed" sw="rw" counter="1" name="memory_reads" hw=""/>
   </reg64>
   <reg64 desc="This register the counters for the preload unit" _absoluteAddress="0x8018" name="cnt_1">
    <hwreg width="32" desc="Counts how many preload instructions were received successfully" sw="rw" counter="1" name="preload_cmds_recv" hw=""/>
    <hwreg width="32" desc="Counts how many preload quadwords were discarded" sw="rw" counter="1" name="preload_qw_discarded" hw=""/>
   </reg64>
   <reg64 desc="more counters" _absoluteAddress="0x8020" name="cnt_2">
    <hwreg width="32" desc="Counts how many cmds were received" sw="rw" counter="1" name="cmds_all" hw=""/>
    <hwreg width="32" desc="Counts how many flush cmds were received" sw="rw" counter="2" name="cmds_flushes" hw=""/>
   </reg64>
   <reg64 desc="more counters" _absoluteAddress="0x8028" name="cnt_3">
    <hwreg width="32" desc="Counts how many fence cmds were received" sw="rw" counter="2" name="cmds_fences" hw=""/>
    <hwreg width="32" desc="Counts how many notification cmds were received" sw="rw" counter="2" name="cmds_noti" hw=""/>
   </reg64>
   <reg64 desc="more counters" _absoluteAddress="0x8030" name="cnt_4">
    <hwreg width="16" desc="Counts how many flush VPID cmds were received" sw="rw" counter="2" name="cmds_vpid" hw=""/>
    <hwreg width="16" desc="Counts how many flush IDX cmds were received" sw="rw" counter="2" name="cmds_idx" hw=""/>
   </reg64>
   <reg64 desc="more counters" _absoluteAddress="0x8038" name="cnt_5">
    <hwreg width="32" desc="Counts how many requests were received" sw="rw" counter="1" name="requests" hw=""/>
    <hwreg width="32" desc="Counts how many requests were for the directly following address in the GAT" sw="rw" counter="2" name="following" hw=""/>
   </reg64>
   <reg64 _absoluteAddress="0x8040" name="fifo_fill_level">
    <hwreg width="7" sw="ro" reset="7'b0" name="replay_current" hw="wo"/>
    <hwreg width="7" sw="rw" reset="7'b0" name="replay_max" hw="rw"/>
    <hwreg width="4" sw="ro" reset="4'b0" name="preload_current" hw="wo"/>
    <hwreg width="4" sw="rw" reset="4'b0" name="preload_max" hw="rw"/>
    <reserved width="2"/>
    <hwreg width="1" desc="Cmd FIFO has run full (SW should take this does not happen)." sw="rw" reset="1'b0" name="cmd_fifo_full" hw="wo"/>
    <hwreg width="1" desc="Replay-CMD FIFO has run full (SW should take this does not happen)." sw="rw" reset="1'b0" name="atu2_replaycmd_fifo_full" hw="wo"/>
   </reg64>
   <reg64 desc="signals from ecc logic" _absoluteAddress="0x8048" name="ecc">
    <hwreg width="1" desc="Double bit error detected in the cmd_fifo." sw="rw" reset="1'b0" name="cmd_fifo_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the cmd_fifo." sw="rw" reset="1'b0" name="cmd_fifo_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in the replay_cmd_fifo." sw="rw" reset="1'b0" name="replay_cmd_fifo_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the replay_cmd_fifo." sw="rw" reset="1'b0" name="replay_cmd_fifo_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in one of the the tlb rams." sw="rw" reset="1'b0" name="tlbram_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in one of the tlb rams." sw="rw" reset="1'b0" name="tlbram_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in the gat_ram." sw="rw" reset="1'b0" name="gat_ram_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the gat_ram." sw="rw" reset="1'b0" name="gat_ram_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in the context_ram." sw="rw" reset="1'b0" name="context_ram_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the context_ram." sw="rw" reset="1'b0" name="context_ram_sec" hw="wo"/>
   </reg64>
   <reg64 _absoluteAddress="0x8050" name="excel_port">
    <hwreg width="1" desc="Set to 1 when the excel is to be used" sw="rw" reset="1'b0" name="active" hw="ro"/>
    <hwreg width="4" desc="target HTAX port behind the excel port" sw="rw" reset="4'b0" name="target_port" hw="ro"/>
   </reg64>
   <reg64 desc="The address in the case the excel port is used" _absoluteAddress="0x8058" name="excel_port_address">
    <hwreg width="64" sw="rw" reset="64'b0" name="excel_port_address" hw="ro"/>
   </reg64>
   <ramblock addrsize="9" ramwidth="64" sw="rw" _absoluteAddress="0x9000" name="preload" external="1" hw="ro"/>
   <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0xa000" name="gat" external="1" hw="ro"/>
  </regroot>
  <regroot _baseAddress="0xc000" _absoluteAddress="0xc000" name="snq_rf">
   <reg64 desc="" _absoluteAddress="0xc000" name="trigger_enable">
    <hwreg width="32" desc="" sw="rw" reset="32'b0" name="trigger_enable" hw="ro"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0xc008" name="trigger_now">
    <hwreg width="32" desc="" sw="rw" reset="32'b0" name="trigger_now" hw="ro"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0xc010" name="trigger_once_enable">
    <hwreg width="32" desc="" sw="wo" reset="32'b0" name="trigger_once_enable" hw="ro"/>
   </reg64>
   <reg64 desc="" _absoluteAddress="0xc018" name="trigger_once">
    <hwreg width="32" desc="" sw="rw" reset="32'b0" name="trigger_once" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc020" name="queue_balt">
    <hwreg width="54" desc="baseaddress (shifted right 10 bits)" sw="rw" reset="54'b0" name="queue_balt" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc028" name="queue_mslt">
    <hwreg width="16" desc="mask" sw="rw" reset="16'b0" name="queue_mslt" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc030" name="queue_wplt">
    <hwreg width="16" desc="write pointer" sw="ro" reset="16'b0" name="queue_wplt" hw="wo"/>
   </reg64>
   <reg64 _absoluteAddress="0xc038" name="queue_rplt">
    <hwreg width="16" desc="read pointer" sw="rw" reset="16'b0" name="queue_rplt" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc040" name="irq_watermark">
    <hwreg width="16" desc="write pointer position to trigger an interrupt" sw="rw" reset="16'b0" name="irq_watermark" hw="ro"/>
    <hwreg width="1" desc="watermark interrupt enable" sw="rw" reset="1'b0" name="enable" hw="ro"/>
   </reg64>
   <reg64 desc="quadword 0 of the interrupt packet" _absoluteAddress="0xc048" name="irq_0">
    <hwreg width="64" sw="rw" reset="64'b0" name="irq_0" hw="ro"/>
   </reg64>
   <reg64 desc="quadword 1 of the interrupt packet" _absoluteAddress="0xc050" name="irq_1">
    <hwreg width="64" sw="rw" reset="64'b0" name="irq_1" hw="ro"/>
   </reg64>
   <reg64 desc="quadword 2 of the interrupt packet" _absoluteAddress="0xc058" name="irq_2">
    <hwreg width="64" sw="rw" reset="64'b0" name="irq_2" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc060" name="dbg_0">
    <hwreg width="3" sw="ro" reset="3'b0" name="htout_state" hw="wo"/>
    <hwreg width="4" sw="ro" reset="4'b0" name="execute_state" hw="wo"/>
    <hwreg width="3" sw="ro" reset="3'b0" name="rf_handler" hw="wo"/>
    <hwreg width="1" desc="Double error deteced in SNQ FIFO." sw="rw" reset="1'b0" name="out_fifo_ded" hw="wo"/>
    <hwreg width="1" desc="Single error corrected in SNQ FIFO." sw="rw" reset="1'b0" name="out_fifo_sec" hw="wo"/>
    <hwreg width="1" desc="Double error deteced in SNQ PRAM." sw="rw" reset="1'b0" name="pram_ded" hw="wo"/>
    <hwreg width="1" desc="Single error corrected in SNQ PRAM." sw="rw" reset="1'b0" name="pram_sec" hw="wo"/>
   </reg64>
   <reg64 _absoluteAddress="0xc068" name="execute">
    <hwreg width="1" desc="" sw="rw" reset="1'b0" name="enable" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0xc070" name="htax">
    <hwreg width="9" desc="" sw="rw" reset="9'b0" name="snqm_port_oh" hw="ro"/>
    <hwreg width="3" desc="" sw="rw" reset="3'b0" name="snqm_vc_oh" hw="ro"/>
    <hwreg width="9" desc="" sw="rw" reset="9'b0" name="irq_port_oh" hw="ro"/>
    <hwreg width="3" desc="" sw="rw" reset="3'b0" name="irq_vc_oh" hw="ro"/>
   </reg64>
   <ramblock addrsize="8" ramwidth="64" sw="rw" _absoluteAddress="0xc800" name="program_ram" external="1" hw="ro"/>
  </regroot>
  <regroot _baseAddress="0x400000" _absoluteAddress="0x400000" name="nw">
   <regroot _baseAddress="0x400000" _absoluteAddress="0x400000" name="xbar_rf">
    <regroot _baseAddress="0x400000" _absoluteAddress="0x400000" name="inp0">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x400000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x400008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x400010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x400018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x400200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x400400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x402000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x404000" _absoluteAddress="0x404000" name="inp1">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x404000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x404008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x404010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x404018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x404200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x404400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x406000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x408000" _absoluteAddress="0x408000" name="inp2">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x408000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x408008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x408010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x408018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x408200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x408400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x40a000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x40c000" _absoluteAddress="0x40c000" name="inp3">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x40c000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x40c008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x40c010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x40c018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x40c200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x40c400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x40e000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x410000" _absoluteAddress="0x410000" name="inp4">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x410000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x410008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x410010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x410018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x410200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x410400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x412000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x414000" _absoluteAddress="0x414000" name="inp5">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x414000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x414008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x414010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x414018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x414200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x414400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x416000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x418000" _absoluteAddress="0x418000" name="inp6">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x418000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x418008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x418010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x418018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x418200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x418400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x41a000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x41c000" _absoluteAddress="0x41c000" name="inp7">
     <reg64 desc="General Control and Status for all In- and Outports" _absoluteAddress="0x41c000" name="routing">
      <hwreg width="1" desc="Allow the use of adaptive routes from deterministic VC" sw="rw" reset="1'b0" name="allow_dvc_avc_switch" hw="ro"/>
      <hwreg width="1" desc="force the deterministic VC to zero in case of fallback" sw="rw" reset="1'b0" name="force_dvc_to_zero" hw="ro"/>
      <hwreg width="1" desc="indicator that routing has been invalid" sw="rw" reset="1'b0" name="illegal_routing" hw="wo"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_dead" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible deadlock is signalled" sw="rw" reset="32'hffffffff" name="timeout_value" hw="ro"/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x41c008" name="rcvd_counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
     </reg64>
     <reg64 desc="Counter for Crossbar Inport" _absoluteAddress="0x41c010" name="send_counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Debug information for the inport" _absoluteAddress="0x41c018" name="debug">
      <hwreg width="8" desc="Double bit error detected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq RAMs." sw="rw" reset="8'b0" name="mq_sec" hw="wo"/>
      <hwreg width="8" desc="Double bit error detected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_ded" hw="wo"/>
      <hwreg width="8" desc="Single bit error corrected in one of the mq pt RAMs." sw="rw" reset="8'b0" name="mq_pt_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the global routing table." sw="rw" reset="1'b0" name="global_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the local routing table." sw="rw" reset="1'b0" name="local_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the multicast routing table." sw="rw" reset="1'b0" name="mcast_route_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the slot ram in the packet store." sw="rw" reset="1'b0" name="slot_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop ram in the packet store." sw="rw" reset="1'b0" name="sop_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the data ram in the packet store." sw="rw" reset="1'b0" name="data_ram_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the free fifo in the packet store." sw="rw" reset="1'b0" name="free_fifo_sec" hw="wo"/>
     </reg64>
     <ramblock addrsize="6" ramwidth="29" sw="rw" _absoluteAddress="0x41c200" name="mcast" external="1" hw="ro">
      <field width="7" name="destination_ports"/>
      <field width="7" name="outgoing_vc0"/>
      <field width="7" name="outgoing_vc1"/>
      <field width="1" name="forward_to_host"/>
      <field width="1" name="forward_to_host_vc0"/>
      <field width="1" name="forward_to_host_vc1"/>
      <field width="4" name="repetition"/>
      <field width="1" name="valid"/>
     </ramblock>
     <ramblock addrsize="6" ramwidth="32" sw="rw" _absoluteAddress="0x41c400" name="grt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
     <ramblock addrsize="10" ramwidth="32" sw="rw" _absoluteAddress="0x41e000" name="lrt" external="1" hw="ro">
      <field width="6" name="TC0_adaptive_ports"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="1" name="TC0_outgoing_vc0"/>
      <field width="3" name="TC0_outgoing_dest_port"/>
      <field width="6" name="TC1_adaptive_ports"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="1" name="TC1_outgoing_vc0"/>
      <field width="3" name="TC1_outgoing_dest_port"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="1" name="TC2_outgoing_vc0"/>
      <field width="3" name="TC2_outgoing_dest_port"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="1" name="TC3_outgoing_vc0"/>
      <field width="3" name="TC3_outgoing_dest_port"/>
     </ramblock>
    </regroot>
    <regroot _baseAddress="0x420000" _absoluteAddress="0x420000" name="outp0">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420000" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420008" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420010" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420018" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x420020" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x420028" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x420040" _absoluteAddress="0x420040" name="outp1">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420040" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420048" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420050" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420058" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x420060" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x420068" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x420080" _absoluteAddress="0x420080" name="outp2">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420080" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420088" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420090" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420098" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x4200a0" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x4200a8" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x4200c0" _absoluteAddress="0x4200c0" name="outp3">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x4200c0" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x4200c8" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x4200d0" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x4200d8" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x4200e0" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x4200e8" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x420100" _absoluteAddress="0x420100" name="outp4">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420100" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420108" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420110" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420118" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x420120" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x420128" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x420140" _absoluteAddress="0x420140" name="outp5">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420140" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420148" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420150" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420158" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x420160" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x420168" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x420180" _absoluteAddress="0x420180" name="outp6">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x420180" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x420188" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x420190" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x420198" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x4201a0" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x4201a8" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x4201c0" _absoluteAddress="0x4201c0" name="outp7">
     <reg64 desc="Counter for Crossbar Outport" _absoluteAddress="0x4201c0" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Holds the used credit count values for all FCCs" _absoluteAddress="0x4201c8" name="fcc_credits">
      <hwreg width="36" desc="current counter values for each FCC" sw="ro" reset="36'b0" name="count" hw="wo"/>
     </reg64>
     <reg64 desc="Holds the overall used credit count value" _absoluteAddress="0x4201d0" name="general">
      <hwreg width="8" desc="current counter value for the total credit count" sw="ro" reset="8'h0" name="total_credits_count" hw="wo"/>
      <hwreg width="6" desc="Indicates which Flow Control Channels are currently available" sw="ro" reset="6'b0" name="avail_fccs" hw="wo"/>
      <hwreg width="1" desc="Indicates That SOX is valid for more than one cycle" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That EOX is valid for more than one cycle" sw="ro" reset="1'h0" name="eox_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two SOX arrived at outport without an EOX in between" sw="ro" reset="1'h0" name="sop_pkt_assertion" hw="wo"/>
      <hwreg width="1" desc="Indicates That two EOX arrived at outport without an SOX in between" sw="ro" reset="1'h0" name="eox_pkt_assertion" hw="wo"/>
      <hwreg width="32" desc="Value in clock ticks that needs to be reached before a possible congestion is signalled" sw="wo" reset="32'hffffffff" name="timeout_value" hw="ro"/>
      <hwreg width="1" desc="" sw="ro" reset="1'b0" name="pos_cong" hw="wo"/>
     </reg64>
     <reg64 desc="This register holds current values of all fcc credit counters" _absoluteAddress="0x4201d8" name="credits_0">
      <hwreg width="6" desc="new counter value for one FCC." sw="rw" reset="6'b0" name="new_fcc_count" hw="ro"/>
      <hwreg width="3" desc="fcc for which the new value is ment for." sw="rw" reset="3'b0" name="fcc" hw="ro"/>
     </reg64>
     <reg64 desc="This register holds current values of the total, shared and fcc_max credit counter" _absoluteAddress="0x4201e0" name="credits_1">
      <hwreg width="8" desc="This register may be written with the new value for the total count. Never write a value larger than MAX_CREDITS in here. This overwrites the current total count with the new value" sw="rw" reset="8'b0" name="new_total_count" hw="ro"/>
      <hwreg width="8" desc="This register may be written with the new value for the maximum total count. Never write a value larger than MAX_CREDITS in here." sw="rw" reset="128" name="new_max_total_count" hw="ro"/>
      <hwreg width="8" desc="The new value of shared credits used. Never write too large values here!" sw="rw" reset="80" name="new_shared_count" hw="ro"/>
      <hwreg width="8" desc="The new maximum number of shared credits." sw="rw" reset="80" name="new_max_shared_count" hw="ro"/>
      <hwreg width="6" desc="The new maximum credits one FCC may use." sw="rw" reset="40" name="new_max_fcc_count" hw="ro"/>
     </reg64>
     <reg64 desc="FCC Mask register" _absoluteAddress="0x4201e8" name="avail_fcc">
      <hwreg width="6" desc="Masks the fcc_available signal between credit admin and fcc arbiter. Flow control channels can therefore be specificly marked as unavailable. These channels won't be arbitrated any more" sw="wo" reset="6'b111111" name="mask" hw="ro"/>
     </reg64>
    </regroot>
   </regroot>
   <regroot _baseAddress="0x440000" _absoluteAddress="0x440000" name="barrier_rf">
    <repeat _iterSize="0x1000" loop="16" _absoluteAddress="0x440000" name="units">
     <reg64 desc="Barrier working set" _offset="0x0" name="work_set">
      <hwreg width="1" desc="Write this register to trigger a barrier" sw="rw" reset="1'h0" name="reached" hw="ro"/>
      <hwreg width="1" desc="Is set when all members have reached the barrier" sw="ro" reset="1'h0" name="released_0" hw="rw"/>
      <hwreg width="1" desc="Is set when all members have reached the barrier" sw="ro" reset="1'h0" name="released_1" hw="rw"/>
      <hwreg width="1" desc="Indicates the active released register, is toggled when reached is written the first time in a barrier operation." sw="ro" reset="1'h0" name="released_active" hw="wo"/>
     </reg64>
    </repeat>
    <repeat _iterSize="0x1000" loop="4" _absoluteAddress="0x450000" name="interrupts">
     <reg64 desc="Global interrupt working set" _offset="0x0" name="work_set">
      <hwreg width="1" desc="Triggers the interrupt." sw="rw" reset="1'h0" name="trigger" hw="ro"/>
      <hwreg width="1" desc="Is set when the interrupt was triggered before." sw="rw" reset="1'h0" name="interrupt" hw="rw"/>
     </reg64>
    </repeat>
    <repeat _iterSize="0x8" loop="16" _absoluteAddress="0x454000" name="units_config">
     <reg64 desc="This Register configures the barrier" _offset="0x0" name="config">
      <hwreg width="1" desc="Enables the barrier unit." sw="rw" reset="1'b0" name="enable" hw="ro"/>
      <hwreg width="4" desc="Bit mask for the child nodes. For each link one bit." sw="rw" reset="4'b0" name="child_nodes" hw="ro"/>
      <hwreg width="4" desc="Indicates the link to the parent node." sw="rw" reset="4'b0" name="parent_nodes" hw="ro"/>
      <hwreg width="4" desc="Number of local processes taking part in the barrier." sw="rw" reset="1'h0" name="host_count" hw="ro"/>
      <hwreg width="1" desc="Resets the barrier unit" sw="rw" reset="1'h0" name="reset" hw="ro"/>
     </reg64>
    </repeat>
    <repeat _iterSize="0x8" loop="4" _absoluteAddress="0x454080" name="interrupts_config">
     <reg64 desc="This Register configures the global interrupt" _offset="0x0" name="config">
      <hwreg width="1" desc="Enables the interrupt unit" sw="rw" reset="1'h0" name="enable" hw="ro"/>
      <hwreg width="4" desc="Bit mask for the child nodes. For each link one bit." sw="rw" reset="4'b0" name="child_nodes" hw="ro"/>
      <hwreg width="16" desc="Number of clock cycles before the local interrupt gets triggered" sw="rw" reset="16'h0" name="delay_count" hw="ro"/>
      <hwreg width="1" desc="Resets the interrupt unit." sw="rw" reset="1'h0" name="reset" hw="ro"/>
      <hwreg width="1" desc="Enables interrupt measurement between two nodes directly connected to each other." sw="rw" reset="1'b0" name="measure" hw="ro"/>
      <hwreg width="16" desc="Starts counting when trigger is set and stops on a received interrupt message." sw="rw" reset="16'b0" name="measure_counter" hw="wo"/>
     </reg64>
    </repeat>
   </regroot>
   <regroot _baseAddress="0x460000" _absoluteAddress="0x460000" name="lp_top_rf">
    <regroot _baseAddress="0x460000" _absoluteAddress="0x460000" name="lp0">
     <reg64 desc="Counter for sent and received pkts" _absoluteAddress="0x460000" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Control and Status registers for the LP" _absoluteAddress="0x460008" name="status">
      <hwreg width="1" desc="Enables the lp out arbiter" sw="rw" reset="1'h1" name="enable" hw="ro"/>
      <hwreg width="1" desc="LP ready is set after a successfull link init" sw="ro" reset="1'b0" name="ready" hw="wo"/>
      <hwreg width="4" desc="Retransmission attempts before the low level link init is restarted." sw="rw" reset="4'h8" name="retrans_attempts" hw="ro"/>
      <hwreg width="1" desc="Restarts the low level link init automatically, if the retranmission fails" sw="rw" reset="1'h1" name="low_level_link_init" hw="ro"/>
      <hwreg width="1" desc="Cell CRC error detected." sw="rw" reset="1'b0" name="cell_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet CRC error detected." sw="rw" reset="1'b0" name="packet_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet was longer than 32 bit times." sw="rw" reset="1'b0" name="packet_length_error" hw="wo"/>
      <hwreg width="1" desc="The protocol checker detected an error." sw="rw" reset="1'b0" name="protocol_error" hw="wo"/>
      <hwreg width="1" desc="LP in fifo overrun." sw="rw" reset="1'b0" name="lp_in_fifo_full" hw="wo"/>
     </reg64>
     <reg64 desc="Counters for the retransmission" _absoluteAddress="0x460010" name="retransmission_counters">
      <hwreg width="14" desc="Counts how many errors have been detected (CRC, protocol,...)" sw="rw" counter="1" name="errors" hw=""/>
      <hwreg width="14" desc="Counts how many retransmissions have been completed" sw="rw" counter="1" name="retransmissions" hw=""/>
      <hwreg width="14" desc="Counts how many nacks have been received" sw="rw" counter="1" name="nack_received" hw=""/>
      <hwreg width="14" desc="Counts how many retrans cells have been sent" sw="rw" counter="1" name="retrans_send" hw=""/>
      <hwreg width="8" desc="Counts how many times a nack was resent due to the nack timeout." sw="rw" counter="1" name="retransmission_timeouts" hw=""/>
     </reg64>
     <reg64 desc="IDS of remote node" _absoluteAddress="0x460018" name="ids">
      <hwreg width="1" desc="Send local GUID to remote node" sw="rw" reset="1'h0" name="send_guid" hw=""/>
      <hwreg width="1" desc="Send local node ID and LP ID to remote node" sw="rw" reset="1'h0" name="send_ids" hw=""/>
      <hwreg width="24" desc="Remote Node Global Unique ID" sw="ro" reset="24'h0" name="remote_guid" hw="wo"/>
      <hwreg width="16" desc="Remote Node ID" sw="ro" reset="16'h0" name="remote_node_id" hw="wo"/>
      <hwreg width="4" desc="ID of the LP on the other side (if any, from 0 to 5 for 6-port EXTOLL" sw="ro" reset="4'h0" name="remote_lp_id" hw="wo"/>
     </reg64>
     <reg64 desc="Status information for the LP in port" _absoluteAddress="0x460020" name="lp_in">
      <hwreg width="1" sw="ro" reset="1'b0" name="guid_received" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="node_id_received" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="info_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="ack_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="barrier_received" hw=""/>
      <hwreg width="4" sw="ro" counter="1" name="cell_crc_error" hw=""/>
      <hwreg width="1" sw="ro" reset="1'b0" name="wait_for_retranmission" hw="wo"/>
      <hwreg width="6" sw="rw" reset="6'h3" name="buffer_threshold" hw="ro"/>
      <hwreg width="1" sw="rw" reset="1'b0" name="buffer_underrun" hw="wo"/>
     </reg64>
     <reg64 desc="LP FSM states" _absoluteAddress="0x460028" name="lp_fsm_states">
      <hwreg width="5" sw="ro" reset="5'b0" name="protocol_checker" hw="wo"/>
      <hwreg width="7" sw="ro" reset="7'b0" name="init" hw="wo"/>
     </reg64>
     <reg64 _absoluteAddress="0x460030" name="lp_out_status">
      <hwreg width="1" sw="ro" reset="1'b0" name="send_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="send_node_id" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="send_info" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_ack" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_barrier" hw=""/>
     </reg64>
     <reg64 _absoluteAddress="0x460038" name="lp_out_arbiter">
      <hwreg width="1" sw="ro" reset="1'b0" name="req_barrier" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_packet" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_info" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_node_id" hw="wo"/>
      <hwreg width="12" sw="ro" reset="12'b0" name="state" hw="wo"/>
     </reg64>
     <reg64 desc="ACK counter" _absoluteAddress="0x460040" name="ack_counter">
      <hwreg width="8" desc="The current tx ack count" sw="ro" reset="8'h0" name="tx_ack" hw="wo"/>
      <hwreg width="8" desc="The current rx ack count" sw="ro" reset="8'h0" name="rx_ack" hw="wo"/>
      <hwreg width="1" desc="Clears the current tx ack count" sw="rw" reset="1'h0" name="tx_ack_clear" hw="ro"/>
      <hwreg width="1" desc="Clears the current rx ack count" sw="rw" reset="1'h0" name="rx_ack_clear" hw="ro"/>
     </reg64>
     <reg64 desc="The credit counters." _absoluteAddress="0x460048" name="credit_counter">
      <hwreg width="8" desc="The current credit count" sw="ro" reset="8'h0" name="counter" hw="wo"/>
      <hwreg width="1" desc="Clears the credit counter" sw="rw" reset="1'h0" name="clear" hw="ro"/>
     </reg64>
     <reg64 desc="Info handler config" _absoluteAddress="0x460050" name="info_handler">
      <hwreg width="6" desc="Minimum credits for a info cell with credits on one FCC" sw="rw" reset="6'h10" name="full_value" hw="ro"/>
     </reg64>
     <reg64 desc="" _absoluteAddress="0x460058" name="timeout">
      <hwreg width="12" sw="rw" reset="12'd512" name="buffer_timeout" hw="ro"/>
     </reg64>
     <reg64 desc="debug counter" _absoluteAddress="0x460060" name="debug">
      <hwreg width="8" sw="ro" counter="1" name="stop_toggle" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_to_phy" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="stop_valid" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_from_phy" hw=""/>
      <hwreg width="1" desc="Double bit error detected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_sec" hw="wo"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x460080" _absoluteAddress="0x460080" name="lp1">
     <reg64 desc="Counter for sent and received pkts" _absoluteAddress="0x460080" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Control and Status registers for the LP" _absoluteAddress="0x460088" name="status">
      <hwreg width="1" desc="Enables the lp out arbiter" sw="rw" reset="1'h1" name="enable" hw="ro"/>
      <hwreg width="1" desc="LP ready is set after a successfull link init" sw="ro" reset="1'b0" name="ready" hw="wo"/>
      <hwreg width="4" desc="Retransmission attempts before the low level link init is restarted." sw="rw" reset="4'h8" name="retrans_attempts" hw="ro"/>
      <hwreg width="1" desc="Restarts the low level link init automatically, if the retranmission fails" sw="rw" reset="1'h1" name="low_level_link_init" hw="ro"/>
      <hwreg width="1" desc="Cell CRC error detected." sw="rw" reset="1'b0" name="cell_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet CRC error detected." sw="rw" reset="1'b0" name="packet_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet was longer than 32 bit times." sw="rw" reset="1'b0" name="packet_length_error" hw="wo"/>
      <hwreg width="1" desc="The protocol checker detected an error." sw="rw" reset="1'b0" name="protocol_error" hw="wo"/>
      <hwreg width="1" desc="LP in fifo overrun." sw="rw" reset="1'b0" name="lp_in_fifo_full" hw="wo"/>
     </reg64>
     <reg64 desc="Counters for the retransmission" _absoluteAddress="0x460090" name="retransmission_counters">
      <hwreg width="14" desc="Counts how many errors have been detected (CRC, protocol,...)" sw="rw" counter="1" name="errors" hw=""/>
      <hwreg width="14" desc="Counts how many retransmissions have been completed" sw="rw" counter="1" name="retransmissions" hw=""/>
      <hwreg width="14" desc="Counts how many nacks have been received" sw="rw" counter="1" name="nack_received" hw=""/>
      <hwreg width="14" desc="Counts how many retrans cells have been sent" sw="rw" counter="1" name="retrans_send" hw=""/>
      <hwreg width="8" desc="Counts how many times a nack was resent due to the nack timeout." sw="rw" counter="1" name="retransmission_timeouts" hw=""/>
     </reg64>
     <reg64 desc="IDS of remote node" _absoluteAddress="0x460098" name="ids">
      <hwreg width="1" desc="Send local GUID to remote node" sw="rw" reset="1'h0" name="send_guid" hw=""/>
      <hwreg width="1" desc="Send local node ID and LP ID to remote node" sw="rw" reset="1'h0" name="send_ids" hw=""/>
      <hwreg width="24" desc="Remote Node Global Unique ID" sw="ro" reset="24'h0" name="remote_guid" hw="wo"/>
      <hwreg width="16" desc="Remote Node ID" sw="ro" reset="16'h0" name="remote_node_id" hw="wo"/>
      <hwreg width="4" desc="ID of the LP on the other side (if any, from 0 to 5 for 6-port EXTOLL" sw="ro" reset="4'h0" name="remote_lp_id" hw="wo"/>
     </reg64>
     <reg64 desc="Status information for the LP in port" _absoluteAddress="0x4600a0" name="lp_in">
      <hwreg width="1" sw="ro" reset="1'b0" name="guid_received" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="node_id_received" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="info_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="ack_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="barrier_received" hw=""/>
      <hwreg width="4" sw="ro" counter="1" name="cell_crc_error" hw=""/>
      <hwreg width="1" sw="ro" reset="1'b0" name="wait_for_retranmission" hw="wo"/>
      <hwreg width="6" sw="rw" reset="6'h3" name="buffer_threshold" hw="ro"/>
      <hwreg width="1" sw="rw" reset="1'b0" name="buffer_underrun" hw="wo"/>
     </reg64>
     <reg64 desc="LP FSM states" _absoluteAddress="0x4600a8" name="lp_fsm_states">
      <hwreg width="5" sw="ro" reset="5'b0" name="protocol_checker" hw="wo"/>
      <hwreg width="7" sw="ro" reset="7'b0" name="init" hw="wo"/>
     </reg64>
     <reg64 _absoluteAddress="0x4600b0" name="lp_out_status">
      <hwreg width="1" sw="ro" reset="1'b0" name="send_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="send_node_id" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="send_info" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_ack" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_barrier" hw=""/>
     </reg64>
     <reg64 _absoluteAddress="0x4600b8" name="lp_out_arbiter">
      <hwreg width="1" sw="ro" reset="1'b0" name="req_barrier" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_packet" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_info" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_node_id" hw="wo"/>
      <hwreg width="12" sw="ro" reset="12'b0" name="state" hw="wo"/>
     </reg64>
     <reg64 desc="ACK counter" _absoluteAddress="0x4600c0" name="ack_counter">
      <hwreg width="8" desc="The current tx ack count" sw="ro" reset="8'h0" name="tx_ack" hw="wo"/>
      <hwreg width="8" desc="The current rx ack count" sw="ro" reset="8'h0" name="rx_ack" hw="wo"/>
      <hwreg width="1" desc="Clears the current tx ack count" sw="rw" reset="1'h0" name="tx_ack_clear" hw="ro"/>
      <hwreg width="1" desc="Clears the current rx ack count" sw="rw" reset="1'h0" name="rx_ack_clear" hw="ro"/>
     </reg64>
     <reg64 desc="The credit counters." _absoluteAddress="0x4600c8" name="credit_counter">
      <hwreg width="8" desc="The current credit count" sw="ro" reset="8'h0" name="counter" hw="wo"/>
      <hwreg width="1" desc="Clears the credit counter" sw="rw" reset="1'h0" name="clear" hw="ro"/>
     </reg64>
     <reg64 desc="Info handler config" _absoluteAddress="0x4600d0" name="info_handler">
      <hwreg width="6" desc="Minimum credits for a info cell with credits on one FCC" sw="rw" reset="6'h10" name="full_value" hw="ro"/>
     </reg64>
     <reg64 desc="" _absoluteAddress="0x4600d8" name="timeout">
      <hwreg width="12" sw="rw" reset="12'd512" name="buffer_timeout" hw="ro"/>
     </reg64>
     <reg64 desc="debug counter" _absoluteAddress="0x4600e0" name="debug">
      <hwreg width="8" sw="ro" counter="1" name="stop_toggle" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_to_phy" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="stop_valid" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_from_phy" hw=""/>
      <hwreg width="1" desc="Double bit error detected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_sec" hw="wo"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x460100" _absoluteAddress="0x460100" name="lp2">
     <reg64 desc="Counter for sent and received pkts" _absoluteAddress="0x460100" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Control and Status registers for the LP" _absoluteAddress="0x460108" name="status">
      <hwreg width="1" desc="Enables the lp out arbiter" sw="rw" reset="1'h1" name="enable" hw="ro"/>
      <hwreg width="1" desc="LP ready is set after a successfull link init" sw="ro" reset="1'b0" name="ready" hw="wo"/>
      <hwreg width="4" desc="Retransmission attempts before the low level link init is restarted." sw="rw" reset="4'h8" name="retrans_attempts" hw="ro"/>
      <hwreg width="1" desc="Restarts the low level link init automatically, if the retranmission fails" sw="rw" reset="1'h1" name="low_level_link_init" hw="ro"/>
      <hwreg width="1" desc="Cell CRC error detected." sw="rw" reset="1'b0" name="cell_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet CRC error detected." sw="rw" reset="1'b0" name="packet_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet was longer than 32 bit times." sw="rw" reset="1'b0" name="packet_length_error" hw="wo"/>
      <hwreg width="1" desc="The protocol checker detected an error." sw="rw" reset="1'b0" name="protocol_error" hw="wo"/>
      <hwreg width="1" desc="LP in fifo overrun." sw="rw" reset="1'b0" name="lp_in_fifo_full" hw="wo"/>
     </reg64>
     <reg64 desc="Counters for the retransmission" _absoluteAddress="0x460110" name="retransmission_counters">
      <hwreg width="14" desc="Counts how many errors have been detected (CRC, protocol,...)" sw="rw" counter="1" name="errors" hw=""/>
      <hwreg width="14" desc="Counts how many retransmissions have been completed" sw="rw" counter="1" name="retransmissions" hw=""/>
      <hwreg width="14" desc="Counts how many nacks have been received" sw="rw" counter="1" name="nack_received" hw=""/>
      <hwreg width="14" desc="Counts how many retrans cells have been sent" sw="rw" counter="1" name="retrans_send" hw=""/>
      <hwreg width="8" desc="Counts how many times a nack was resent due to the nack timeout." sw="rw" counter="1" name="retransmission_timeouts" hw=""/>
     </reg64>
     <reg64 desc="IDS of remote node" _absoluteAddress="0x460118" name="ids">
      <hwreg width="1" desc="Send local GUID to remote node" sw="rw" reset="1'h0" name="send_guid" hw=""/>
      <hwreg width="1" desc="Send local node ID and LP ID to remote node" sw="rw" reset="1'h0" name="send_ids" hw=""/>
      <hwreg width="24" desc="Remote Node Global Unique ID" sw="ro" reset="24'h0" name="remote_guid" hw="wo"/>
      <hwreg width="16" desc="Remote Node ID" sw="ro" reset="16'h0" name="remote_node_id" hw="wo"/>
      <hwreg width="4" desc="ID of the LP on the other side (if any, from 0 to 5 for 6-port EXTOLL" sw="ro" reset="4'h0" name="remote_lp_id" hw="wo"/>
     </reg64>
     <reg64 desc="Status information for the LP in port" _absoluteAddress="0x460120" name="lp_in">
      <hwreg width="1" sw="ro" reset="1'b0" name="guid_received" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="node_id_received" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="info_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="ack_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="barrier_received" hw=""/>
      <hwreg width="4" sw="ro" counter="1" name="cell_crc_error" hw=""/>
      <hwreg width="1" sw="ro" reset="1'b0" name="wait_for_retranmission" hw="wo"/>
      <hwreg width="6" sw="rw" reset="6'h3" name="buffer_threshold" hw="ro"/>
      <hwreg width="1" sw="rw" reset="1'b0" name="buffer_underrun" hw="wo"/>
     </reg64>
     <reg64 desc="LP FSM states" _absoluteAddress="0x460128" name="lp_fsm_states">
      <hwreg width="5" sw="ro" reset="5'b0" name="protocol_checker" hw="wo"/>
      <hwreg width="7" sw="ro" reset="7'b0" name="init" hw="wo"/>
     </reg64>
     <reg64 _absoluteAddress="0x460130" name="lp_out_status">
      <hwreg width="1" sw="ro" reset="1'b0" name="send_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="send_node_id" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="send_info" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_ack" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_barrier" hw=""/>
     </reg64>
     <reg64 _absoluteAddress="0x460138" name="lp_out_arbiter">
      <hwreg width="1" sw="ro" reset="1'b0" name="req_barrier" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_packet" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_info" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_node_id" hw="wo"/>
      <hwreg width="12" sw="ro" reset="12'b0" name="state" hw="wo"/>
     </reg64>
     <reg64 desc="ACK counter" _absoluteAddress="0x460140" name="ack_counter">
      <hwreg width="8" desc="The current tx ack count" sw="ro" reset="8'h0" name="tx_ack" hw="wo"/>
      <hwreg width="8" desc="The current rx ack count" sw="ro" reset="8'h0" name="rx_ack" hw="wo"/>
      <hwreg width="1" desc="Clears the current tx ack count" sw="rw" reset="1'h0" name="tx_ack_clear" hw="ro"/>
      <hwreg width="1" desc="Clears the current rx ack count" sw="rw" reset="1'h0" name="rx_ack_clear" hw="ro"/>
     </reg64>
     <reg64 desc="The credit counters." _absoluteAddress="0x460148" name="credit_counter">
      <hwreg width="8" desc="The current credit count" sw="ro" reset="8'h0" name="counter" hw="wo"/>
      <hwreg width="1" desc="Clears the credit counter" sw="rw" reset="1'h0" name="clear" hw="ro"/>
     </reg64>
     <reg64 desc="Info handler config" _absoluteAddress="0x460150" name="info_handler">
      <hwreg width="6" desc="Minimum credits for a info cell with credits on one FCC" sw="rw" reset="6'h10" name="full_value" hw="ro"/>
     </reg64>
     <reg64 desc="" _absoluteAddress="0x460158" name="timeout">
      <hwreg width="12" sw="rw" reset="12'd512" name="buffer_timeout" hw="ro"/>
     </reg64>
     <reg64 desc="debug counter" _absoluteAddress="0x460160" name="debug">
      <hwreg width="8" sw="ro" counter="1" name="stop_toggle" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_to_phy" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="stop_valid" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_from_phy" hw=""/>
      <hwreg width="1" desc="Double bit error detected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_sec" hw="wo"/>
     </reg64>
    </regroot>
    <regroot _baseAddress="0x460180" _absoluteAddress="0x460180" name="lp3">
     <reg64 desc="Counter for sent and received pkts" _absoluteAddress="0x460180" name="counter">
      <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
      <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
     </reg64>
     <reg64 desc="Control and Status registers for the LP" _absoluteAddress="0x460188" name="status">
      <hwreg width="1" desc="Enables the lp out arbiter" sw="rw" reset="1'h1" name="enable" hw="ro"/>
      <hwreg width="1" desc="LP ready is set after a successfull link init" sw="ro" reset="1'b0" name="ready" hw="wo"/>
      <hwreg width="4" desc="Retransmission attempts before the low level link init is restarted." sw="rw" reset="4'h8" name="retrans_attempts" hw="ro"/>
      <hwreg width="1" desc="Restarts the low level link init automatically, if the retranmission fails" sw="rw" reset="1'h1" name="low_level_link_init" hw="ro"/>
      <hwreg width="1" desc="Cell CRC error detected." sw="rw" reset="1'b0" name="cell_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet CRC error detected." sw="rw" reset="1'b0" name="packet_crc_error" hw="wo"/>
      <hwreg width="1" desc="Packet was longer than 32 bit times." sw="rw" reset="1'b0" name="packet_length_error" hw="wo"/>
      <hwreg width="1" desc="The protocol checker detected an error." sw="rw" reset="1'b0" name="protocol_error" hw="wo"/>
      <hwreg width="1" desc="LP in fifo overrun." sw="rw" reset="1'b0" name="lp_in_fifo_full" hw="wo"/>
     </reg64>
     <reg64 desc="Counters for the retransmission" _absoluteAddress="0x460190" name="retransmission_counters">
      <hwreg width="14" desc="Counts how many errors have been detected (CRC, protocol,...)" sw="rw" counter="1" name="errors" hw=""/>
      <hwreg width="14" desc="Counts how many retransmissions have been completed" sw="rw" counter="1" name="retransmissions" hw=""/>
      <hwreg width="14" desc="Counts how many nacks have been received" sw="rw" counter="1" name="nack_received" hw=""/>
      <hwreg width="14" desc="Counts how many retrans cells have been sent" sw="rw" counter="1" name="retrans_send" hw=""/>
      <hwreg width="8" desc="Counts how many times a nack was resent due to the nack timeout." sw="rw" counter="1" name="retransmission_timeouts" hw=""/>
     </reg64>
     <reg64 desc="IDS of remote node" _absoluteAddress="0x460198" name="ids">
      <hwreg width="1" desc="Send local GUID to remote node" sw="rw" reset="1'h0" name="send_guid" hw=""/>
      <hwreg width="1" desc="Send local node ID and LP ID to remote node" sw="rw" reset="1'h0" name="send_ids" hw=""/>
      <hwreg width="24" desc="Remote Node Global Unique ID" sw="ro" reset="24'h0" name="remote_guid" hw="wo"/>
      <hwreg width="16" desc="Remote Node ID" sw="ro" reset="16'h0" name="remote_node_id" hw="wo"/>
      <hwreg width="4" desc="ID of the LP on the other side (if any, from 0 to 5 for 6-port EXTOLL" sw="ro" reset="4'h0" name="remote_lp_id" hw="wo"/>
     </reg64>
     <reg64 desc="Status information for the LP in port" _absoluteAddress="0x4601a0" name="lp_in">
      <hwreg width="1" sw="ro" reset="1'b0" name="guid_received" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="node_id_received" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="info_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="ack_received" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="barrier_received" hw=""/>
      <hwreg width="4" sw="ro" counter="1" name="cell_crc_error" hw=""/>
      <hwreg width="1" sw="ro" reset="1'b0" name="wait_for_retranmission" hw="wo"/>
      <hwreg width="6" sw="rw" reset="6'h3" name="buffer_threshold" hw="ro"/>
      <hwreg width="1" sw="rw" reset="1'b0" name="buffer_underrun" hw="wo"/>
     </reg64>
     <reg64 desc="LP FSM states" _absoluteAddress="0x4601a8" name="lp_fsm_states">
      <hwreg width="5" sw="ro" reset="5'b0" name="protocol_checker" hw="wo"/>
      <hwreg width="7" sw="ro" reset="7'b0" name="init" hw="wo"/>
     </reg64>
     <reg64 _absoluteAddress="0x4601b0" name="lp_out_status">
      <hwreg width="1" sw="ro" reset="1'b0" name="send_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="send_node_id" hw="wo"/>
      <hwreg width="16" sw="ro" counter="1" name="send_info" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_ack" hw=""/>
      <hwreg width="16" sw="ro" counter="1" name="send_barrier" hw=""/>
     </reg64>
     <reg64 _absoluteAddress="0x4601b8" name="lp_out_arbiter">
      <hwreg width="1" sw="ro" reset="1'b0" name="req_barrier" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_packet" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_info" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_guid" hw="wo"/>
      <hwreg width="1" sw="ro" reset="1'b0" name="req_node_id" hw="wo"/>
      <hwreg width="12" sw="ro" reset="12'b0" name="state" hw="wo"/>
     </reg64>
     <reg64 desc="ACK counter" _absoluteAddress="0x4601c0" name="ack_counter">
      <hwreg width="8" desc="The current tx ack count" sw="ro" reset="8'h0" name="tx_ack" hw="wo"/>
      <hwreg width="8" desc="The current rx ack count" sw="ro" reset="8'h0" name="rx_ack" hw="wo"/>
      <hwreg width="1" desc="Clears the current tx ack count" sw="rw" reset="1'h0" name="tx_ack_clear" hw="ro"/>
      <hwreg width="1" desc="Clears the current rx ack count" sw="rw" reset="1'h0" name="rx_ack_clear" hw="ro"/>
     </reg64>
     <reg64 desc="The credit counters." _absoluteAddress="0x4601c8" name="credit_counter">
      <hwreg width="8" desc="The current credit count" sw="ro" reset="8'h0" name="counter" hw="wo"/>
      <hwreg width="1" desc="Clears the credit counter" sw="rw" reset="1'h0" name="clear" hw="ro"/>
     </reg64>
     <reg64 desc="Info handler config" _absoluteAddress="0x4601d0" name="info_handler">
      <hwreg width="6" desc="Minimum credits for a info cell with credits on one FCC" sw="rw" reset="6'h10" name="full_value" hw="ro"/>
     </reg64>
     <reg64 desc="" _absoluteAddress="0x4601d8" name="timeout">
      <hwreg width="12" sw="rw" reset="12'd512" name="buffer_timeout" hw="ro"/>
     </reg64>
     <reg64 desc="debug counter" _absoluteAddress="0x4601e0" name="debug">
      <hwreg width="8" sw="ro" counter="1" name="stop_toggle" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_to_phy" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="stop_valid" hw=""/>
      <hwreg width="8" sw="ro" counter="1" name="valid_from_phy" hw=""/>
      <hwreg width="1" desc="Double bit error detected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_in data fifo." sw="rw" reset="1'b0" name="lp_in_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the lp_out data fifo." sw="rw" reset="1'b0" name="lp_out_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the sop_fifo data fifo." sw="rw" reset="1'b0" name="sop_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the packet_fifo data fifo." sw="rw" reset="1'b0" name="packet_fifo_sec" hw="wo"/>
      <hwreg width="1" desc="Double bit error detected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_ded" hw="wo"/>
      <hwreg width="1" desc="Single bit error corrected in the size_fifo data fifo." sw="rw" reset="1'b0" name="size_fifo_sec" hw="wo"/>
     </reg64>
    </regroot>
   </regroot>
   <regroot _baseAddress="0x460200" _absoluteAddress="0x460200" name="phy_rf">
    <repeat _iterSize="0x20" loop="4" _absoluteAddress="0x460200" name="link">
     <reg64 desc="Control and Status registers for the LP" _offset="0x0" name="status">
      <hwreg width="1" desc="PHY initialization can be restarted by setting this bit, needs to be reset after a while" sw="rw" reset="1'h0" name="restart_link" hw="ro"/>
      <hwreg width="1" desc="TX part of physical link has been resetted successfully if bit is set" sw="ro" reset="1'h0" name="tx_reset_done" hw="wo"/>
      <hwreg width="1" desc="RX part of physical link has been resetted successfully if bit is set" sw="ro" reset="1'h0" name="rx_reset_done" hw="wo"/>
      <hwreg width="1" desc="Physical link has been established if bit is set" sw="ro" reset="1'h0" name="phy_rdy" hw="wo"/>
      <hwreg width="3" desc="{stop_and_shift_in, tx_system_ready_i[0], tx_system_almost_ready_i[0]}" sw="ro" reset="3'h0" name="dbg_txstatus0" hw="wo"/>
      <hwreg width="3" desc="{stop_and_shift_in, tx_system_ready_i[1], tx_system_almost_ready_i[1]}" sw="ro" reset="3'h0" name="dbg_txstatus1" hw="wo"/>
      <hwreg width="3" desc="{stop_and_shift_in, tx_system_ready_i[2], tx_system_almost_ready_i[2]}" sw="ro" reset="3'h0" name="dbg_txstatus2" hw="wo"/>
      <hwreg width="3" desc="{stop_and_shift_in, tx_system_ready_i[3], tx_system_almost_ready_i[3]}" sw="ro" reset="3'h0" name="dbg_txstatus3" hw="wo"/>
      <hwreg width="9" desc="{dbg_rxsifull_ass, rx_system_ready_i[0], rx_almost_ready_i[0], rx_see_ready0_RRM2TRM[0], rx_saw_ready1_RRM2TRM[0], rx_valid_char_RRM2TRM[0], rx_reinit[0], rxrm2txreset[0], enable_bonding[0]}" sw="ro" reset="9'h0" name="dbg_rxstatus0" hw="wo"/>
      <hwreg width="9" desc="{dbg_rxsifull_ass, rx_system_ready_i[1], rx_almost_ready_i[1], rx_see_ready0_RRM2TRM[1], rx_saw_ready1_RRM2TRM[1], rx_valid_char_RRM2TRM[1], rx_reinit[1], rxrm2txreset[1], enable_bonding[1]}" sw="ro" reset="9'h0" name="dbg_rxstatus1" hw="wo"/>
      <hwreg width="9" desc="{dbg_rxsifull_ass, rx_system_ready_i[2], rx_almost_ready_i[2], rx_see_ready0_RRM2TRM[2], rx_saw_ready2_RRM2TRM[2], rx_valid_char_RRM2TRM[2], rx_reinit[2], rxrm2txreset[2], enable_bonding[2]}" sw="ro" reset="9'h0" name="dbg_rxstatus2" hw="wo"/>
      <hwreg width="9" desc="{dbg_rxsifull_ass, rx_system_ready_i[3], rx_almost_ready_i[3], rx_see_ready0_RRM2TRM[3], rx_saw_ready3_RRM2TRM[3], rx_valid_char_RRM2TRM[3], rx_reinit[3], rxrm2txreset[3], enable_bonding[3]}" sw="ro" reset="9'h0" name="dbg_rxstatus3" hw="wo"/>
     </reg64>
     <reg64 desc="Debug counter for packet counting" _offset="0x8" name="dbg_cnt">
      <hwreg width="4" desc="Number of non-IDLE phits arrived on this link" sw="ro" reset="4'h0" name="rxdata_cnt" hw="wo"/>
      <hwreg width="4" desc="Number of phits shifted into channel aligner of this link" sw="ro" reset="4'h0" name="rxsi_cnt" hw="wo"/>
      <hwreg width="4" desc="Number of phits shifted out of channel aligner of this link" sw="ro" reset="4'h0" name="rxso_cnt" hw="wo"/>
     </reg64>
     <reg64 desc="Misc overrides for the PHY" _offset="0x10" name="overrides">
      <hwreg width="1" desc="This overrides the stop indicator from PHY to LP, affecting data sending." sw="rw" reset="1'h0" name="stop_phy2lp_rf_ovrd" hw="ro"/>
      <hwreg width="1" desc="This overrides the valid indicator from PHY to LP, affecting received data." sw="rw" reset="1'h1" name="valid_phy2lp_rf_ovrd" hw="ro"/>
      <hwreg width="3" desc="Enable the PRBS test function. 000: off; 001: PRBS-7; 010: PRBS-15; 011: PRBS-23; 100: PRBS-31; 101: PCI Express; 110: CLK pattern; 111: CLK/10" sw="rw" reset="3'b0" name="enable_prbs" hw="ro"/>
      <hwreg width="1" desc="Setting this reg to 1 sets the PRBS error counter back to 0. Don't forget to set back to 0." sw="rw" reset="1'b0" name="reinit_prbs_errcnt" hw="ro"/>
      <hwreg width="1" desc="Control for error detection in the receiver. Enabled by default. (too much errors -> reinit link)" sw="rw" reset="1'h1" name="rx_errordet_en" hw="ro"/>
      <hwreg width="1" desc="Enable the detection of link reinitialization in the receiver. Enabled by default. (detect reinit chars on link -> reinit link)" sw="rw" reset="1'h1" name="remote_restart_en" hw="ro"/>
     </reg64>
     <reg64 desc="PRBS Error counter" _offset="0x18" name="PRBS_errorcnt">
      <hwreg width="16" desc="This is the error counter value of lane 0." sw="ro" reset="16'h0" name="prbs_errcnt_0" hw="wo"/>
      <hwreg width="16" desc="This is the error counter value of lane 1." sw="ro" reset="16'h0" name="prbs_errcnt_1" hw="wo"/>
      <hwreg width="16" desc="This is the error counter value of lane 2." sw="ro" reset="16'h0" name="prbs_errcnt_2" hw="wo"/>
      <hwreg width="16" desc="This is the error counter value of lane 3." sw="ro" reset="16'h0" name="prbs_errcnt_3" hw="wo"/>
     </reg64>
    </repeat>
   </regroot>
  </regroot>
  <regroot _baseAddress="0xc00000" _absoluteAddress="0xc00000" name="buffer_queue_rf">
   <regroot _baseAddress="0xc00000" _absoluteAddress="0xc00000" name="velo">
    <reg64 desc="This register holds the enable bits of the buffer queue units" _absoluteAddress="0xc00000" name="general">
     <hwreg width="1" desc="Enable Buffer Queue functionality" sw="rw" reset="1'b0" name="enable" hw="ro"/>
     <hwreg width="1" desc="Assertion that indicates that the logical write pointer passed the upper bound" sw="rw" reset="1'b0" name="ub_assert" hw="wo"/>
     <hwreg width="1" desc="Assertion that indicates that the commit or discard of an address taken too long" sw="rw" reset="1'b0" name="timeout_assert" hw="wo"/>
     <hwreg width="1" desc="Assertion that indicates that the local write pointer passed the segment size" sw="rw" reset="1'b0" name="lwp_assert" hw="wo"/>
     <hwreg width="8" desc="Queue where the last error occured" sw="ro" reset="8'b0" name="error_queue" hw="wo"/>
     <hwreg width="32" sw="rw" counter="1" name="error_count" hw=""/>
    </reg64>
    <reg64 desc="This register holds debug information for the buffer queue" _absoluteAddress="0xc00008" name="debug">
     <hwreg width="5" desc="current state of buffer queue" sw="ro" reset="1'b0" name="state" hw="wo"/>
     <hwreg width="32" desc="number of processed descriptor responses" sw="rw" counter="1" name="rcvd_dcqs" hw=""/>
     <hwreg width="1" desc="Double bit error detected in buffer queue ram." sw="rw" reset="1'b0" name="ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single bit error corrected in buffer queue ram." sw="rw" reset="1'b0" name="ram_sec" hw="wo"/>
    </reg64>
    <ramblock addrsize="8" ramwidth="43" sw="rw" _absoluteAddress="0xc00800" name="ub" external="1" hw="ro">
     <field width="32" name="upper_bound"/>
     <field width="1" name="tph_enable"/>
     <field width="2" name="tph_hints"/>
     <field width="8" name="tph_stag"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="56" sw="rw" _absoluteAddress="0xc01000" name="dcq_base_dcq_ub" external="1" hw="ro">
     <field width="16" name="dcq_ub"/>
     <field width="40" name="dcq_base"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="59" sw="rw" _absoluteAddress="0xc01800" name="c_base_size_valid" external="1" hw="rw">
     <field width="2" name="c_slot_size"/>
     <field width="16" name="c_segment_size"/>
     <field width="40" name="c_base"/>
     <field width="1" name="c_valid"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="59" sw="rw" _absoluteAddress="0xc02000" name="n_base_size_valid" external="1" hw="rw">
     <field width="2" name="n_slot_size"/>
     <field width="16" name="n_segment_size"/>
     <field width="40" name="n_base"/>
     <field width="1" name="n_valid"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="64" sw="rw" _absoluteAddress="0xc02800" name="wp_lwp_dcq_rp" external="1" hw="rw">
     <field width="16" name="dcq_rp"/>
     <field width="16" name="lwp"/>
     <field width="32" name="wp"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="33" sw="rw" addr_shift="9" _absoluteAddress="0xd00000" name="rp" external="1" hw="ro">
     <field width="32" name="rp"/>
     <field width="1" name="trigger_int_update"/>
    </ramblock>
   </regroot>
   <regroot _baseAddress="0xe00000" _absoluteAddress="0xe00000" name="rma">
    <reg64 desc="This register holds the enable bits of the buffer queue units" _absoluteAddress="0xe00000" name="general">
     <hwreg width="1" desc="Enable Buffer Queue functionality" sw="rw" reset="1'b0" name="enable" hw="ro"/>
     <hwreg width="1" desc="Assertion that indicates that the logical write pointer passed the upper bound" sw="rw" reset="1'b0" name="ub_assert" hw="wo"/>
     <hwreg width="1" desc="Assertion that indicates that the commit or discard of an address taken too long" sw="rw" reset="1'b0" name="timeout_assert" hw="wo"/>
     <hwreg width="1" desc="Assertion that indicates that the local write pointer passed the segment size" sw="rw" reset="1'b0" name="lwp_assert" hw="wo"/>
     <hwreg width="8" desc="Queue where the last error occured" sw="ro" reset="8'b0" name="error_queue" hw="wo"/>
     <hwreg width="32" sw="rw" counter="1" name="error_count" hw=""/>
    </reg64>
    <reg64 desc="This register holds debug information for the buffer queue" _absoluteAddress="0xe00008" name="debug">
     <hwreg width="5" desc="current state of buffer queue" sw="ro" reset="1'b0" name="state" hw="wo"/>
     <hwreg width="32" desc="number of processed descriptor responses" sw="rw" counter="1" name="rcvd_dcqs" hw=""/>
     <hwreg width="1" desc="Double bit error detected in buffer queue ram." sw="rw" reset="1'b0" name="ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single bit error corrected in buffer queue ram." sw="rw" reset="1'b0" name="ram_sec" hw="wo"/>
    </reg64>
    <ramblock addrsize="8" ramwidth="43" sw="rw" _absoluteAddress="0xe00800" name="ub" external="1" hw="ro">
     <field width="32" name="upper_bound"/>
     <field width="1" name="tph_enable"/>
     <field width="2" name="tph_hints"/>
     <field width="8" name="tph_stag"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="56" sw="rw" _absoluteAddress="0xe01000" name="dcq_base_dcq_ub" external="1" hw="ro">
     <field width="16" name="dcq_ub"/>
     <field width="40" name="dcq_base"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="59" sw="rw" _absoluteAddress="0xe01800" name="c_base_size_valid" external="1" hw="rw">
     <field width="2" name="c_slot_size"/>
     <field width="16" name="c_segment_size"/>
     <field width="40" name="c_base"/>
     <field width="1" name="c_valid"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="59" sw="rw" _absoluteAddress="0xe02000" name="n_base_size_valid" external="1" hw="rw">
     <field width="2" name="n_slot_size"/>
     <field width="16" name="n_segment_size"/>
     <field width="40" name="n_base"/>
     <field width="1" name="n_valid"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="64" sw="rw" _absoluteAddress="0xe02800" name="wp_lwp_dcq_rp" external="1" hw="rw">
     <field width="16" name="dcq_rp"/>
     <field width="16" name="lwp"/>
     <field width="32" name="wp"/>
    </ramblock>
    <ramblock addrsize="8" ramwidth="33" sw="rw" addr_shift="9" _absoluteAddress="0xf00000" name="rp" external="1" hw="ro">
     <field width="32" name="rp"/>
     <field width="1" name="trigger_int_update"/>
    </ramblock>
   </regroot>
  </regroot>
  <regroot _baseAddress="0x1000000" _absoluteAddress="0x1000000" name="velo_rf">
   <regroot _baseAddress="0x1000000" _absoluteAddress="0x1000000" name="wcbuf_rf">
    <ramblock addrsize="8" ramwidth="64" sw="rw" addr_shift="9" _absoluteAddress="0x1000000" name="state" external="1" hw="rw">
     <field width="24" name="commited_packet_counter"/>
     <field width="8" name="current_packet_length"/>
     <field width="1" name="retry_bit"/>
     <field width="1" name="assembly_full_bit"/>
     <field width="1" name="streamout_full_bit"/>
     <field width="5" name="reserved1"/>
     <field width="8" name="word_count"/>
     <field width="8" name="reserved2"/>
     <field width="8" name="retry_packet_count"/>
    </ramblock>
    <reg64 desc="This register is used to control timeout of incoming requests at the Write-Combining-Buffer. Also the forwarding latency can be tuned" _absoluteAddress="0x1100000" name="timeout">
     <hwreg width="1" desc="This is an enable flag for the timeout functioniality. Only if this bit is set, timeout may occur, otherwise the WCB may wait infinitely." sw="rw" reset="1'b0" name="timeout_active" hw="ro"/>
     <hwreg width="1" desc="Is set, the latency counter feature is used, otherwise packet data is forwarded to the streamout stage when the packet has been completely received (store-and-forward mode)." sw="rw" reset="1'b0" name="lat_counter_enable" hw="ro"/>
     <reserved width="6"/>
     <hwreg width="8" desc="This is the number of cycles waited after a packet is seen to complete in the assembly stage before control information is forwarded to the streamout stage." sw="rw" reset="8'hff" name="lat_counter_value" hw="ro"/>
     <reserved width="16"/>
     <hwreg width="32" desc="The timeout threshold. Gives the number of cycles that should be waited before going into retry state." sw="rw" reset="32'b0" name="timeout" hw="ro"/>
    </reg64>
    <reg64 desc="Error flags of the WCB" _absoluteAddress="0x1100008" name="errors0">
     <hwreg width="24" desc="Incremented whenever a HTOC packet is not quadword sized." sw="rw" counter="1" name="qw_length_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest qw length error." sw="rw" reset="8'b0" name="qw_length_error_vpid" hw="wo"/>
     <hwreg width="24" desc="Incremented whenever a message is too long for this WCB." sw="rw" counter="1" name="msg_too_long_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest message too long error." sw="rw" reset="8'b0" name="msg_too_long_vpid" hw="wo"/>
    </reg64>
    <reg64 desc="Error flags of the WCB" _absoluteAddress="0x1100010" name="errors1">
     <hwreg width="24" desc="Incremented whenever a HTOC packet is not qword aligned, that arrives at the wcbuf." sw="rw" counter="1" name="msg_not_aligned_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest packet not aligned error." sw="rw" reset="8'b0" name="msg_not_alinged_vpid" hw="wo"/>
     <hwreg width="24" desc="Incremented whenever a HTOC packet is too long for this WCB." sw="rw" counter="1" name="pkt_too_long_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest packet too long error." sw="rw" reset="8'b0" name="pkt_too_long_vpid" hw="wo"/>
    </reg64>
    <reg64 desc="This register controls the  WCB Event Mirroring facility, i.e. if and how status changes are reflected to main memory." _absoluteAddress="0x1100018" name="event_mirror">
     <hwreg width="8" desc="This bit gives the condition, when the packet counter is mirrored to main memory. One bit should be set to one. If this bit toggles, the value in main memory is updated. Set this register to 0 to disable mirroring of counter updates. For example, if bit 4 is set, every 16 requests the counter is mirrored to main memory." sw="rw" reset="8'b0" name="commited_packet_mirror_mask" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes of the retry counter." sw="rw" reset="1'b0" name="enable_mirror_retrycounter" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes to the commited packet counter (if enabled)." sw="rw" reset="1'b0" name="enable_update_commited_packets" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes that were performed by software by writing to the state block." sw="rw" reset="1'b0" name="enable_update_sw" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of updates to the retry status bit. Can save SW the work to save rejected packet count to main-memory/read from device." sw="rw" reset="1'b0" name="enable_mirror_retried" hw="ro"/>
     <hwreg width="52" desc="Main memory base address, where status updates are mirrored to. One page per VPID needed. In this page, a single quadword with offset 0 is used as target of the status updates." sw="rw" reset="52'b0" name="status_mirror_base" hw="ro"/>
    </reg64>
    <reg64 desc="The base address register for the WCB Packet Mirroring facility, i.e. if and how discarded packets are reflected to main memory." _absoluteAddress="0x1100020" name="retry_mirror_base">
     <hwreg width="1" desc="Enable/disabled mirroring of discarded packets." sw="rw" reset="1'b0" name="packet_enable_mirror" hw="ro"/>
     <hwreg width="8" desc="This register encodes the sizse of the mirror region in entries per VPID. Mask/thermocode is used. if all 1s, this means 256 entries per VPID are enabled. An entry has maximum message size, i.e. 32byte for RMA which translates to 2 MB of physical memory with 256 entries. and 8 MB for VELO2" sw="rw" reset="8'b0" name="packet_mirror_size" hw="ro"/>
     <reserved width="3"/>
     <hwreg width="52" desc="This registers holds the base address of the area where discarded packets are mirrored to. One page per VPID is needed. How large the actual region is (within this page) used to store packets is determined by the mirror_size field. Note, that this field holds the physical address, without page offset. If the packet_mirror_size is larger than 5'b11111, more than one page is needed per VPID in the VELO2 case, than the address has to be aligned accordingly." sw="rw" reset="52'b0" name="packet_mirror_base" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds all of the ECC status information from the WCBUF RAM Buffers" _absoluteAddress="0x1100028" name="ecc_status">
     <hwreg width="1" desc="Double error deteced in wcbuf state rams." sw="rw" reset="1'b0" name="state_ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf state rams." sw="rw" reset="1'b0" name="state_ram_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf assembly buffer ram." sw="rw" reset="1'b0" name="buffer_ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf assembly buffer ram." sw="rw" reset="1'b0" name="buffer_ram_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf datain fifo ram." sw="rw" reset="1'b0" name="datain_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf datain fifo ram." sw="rw" reset="1'b0" name="datain_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf ctlin fifo ram." sw="rw" reset="1'b0" name="ctlin_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf ctlin fifo ram." sw="rw" reset="1'b0" name="ctlin_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf assembled_queue fifo ram." sw="rw" reset="1'b0" name="assembled_queue_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf assembled_queue fifo ram." sw="rw" reset="1'b0" name="assembled_queue_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf dataout fifo ram." sw="rw" reset="1'b0" name="dataout_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf dataout fifo ram." sw="rw" reset="1'b0" name="dataout_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf rdy_queue fifo ram." sw="rw" reset="1'b0" name="rdy_queue_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf rdy_queue fifo ram." sw="rw" reset="1'b0" name="rdy_queue_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf mirror fifo ram." sw="rw" reset="1'b0" name="mirror_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf mirror fifo ram." sw="rw" reset="1'b0" name="mirror_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
   <regroot _baseAddress="0x1200000" _absoluteAddress="0x1200000" name="noti_interrupt_handler">
    <reg64 _absoluteAddress="0x1200000" name="int_ctrl">
     <hwreg width="1" desc="Changes on this register initiate an SNQ trigger event." sw="" reset="1'b0" name="toggle" hw="wo"/>
    </reg64>
    <ramblock addrsize="2" ramwidth="64" sw="ro" _absoluteAddress="0x1200020" name="int_vec" external="1" hw="rw"/>
    <ramblock addrsize="2" ramwidth="64" sw="rw" _absoluteAddress="0x1200040" name="int_retrig_vec" external="1" hw="rw"/>
   </regroot>
   <ramblock addrsize="8" ramwidth="42" sw="rw" _absoluteAddress="0x1200800" name="node_vpid_prot_desc" external="1" hw="ro">
    <field width="16" name="protection_desc"/>
    <field width="16" name="source_node"/>
    <field width="10" name="source_vpid"/>
   </ramblock>
   <ramblock addrsize="8" ramwidth="18" sw="rw" _absoluteAddress="0x1201000" name="comp_prot_desc" external="1" hw="ro">
    <field width="16" name="protection_desc"/>
    <field width="1" name="alternative_target"/>
    <field width="1" name="enable"/>
   </ramblock>
   <reg64 desc="In this register the timeout value for VELO can be set. If activated VELO requests addresses for the amount given before discarding packets of a full mailbox" _absoluteAddress="0x1201800" name="timeout">
    <hwreg width="32" sw="rw" reset="32'h0" name="value" hw="ro"/>
    <hwreg width="1" sw="rw" reset="1'h0" name="enable" hw="ro"/>
   </reg64>
   <reg64 _absoluteAddress="0x1201808" name="completer">
    <hwreg width="9" desc="In this register the alternative target port for velo packets can be set in a one_hot coding style" sw="rw" reset="9'h0" name="target_htax_port" hw="ro"/>
    <hwreg width="1" desc="VELO Completer builds 128 byte packets instead of 64 byte when this bit is set." sw="rw" reset="1'h0" name="packets_128B" hw="ro"/>
   </reg64>
   <reg64 desc="This register that holds counter fields for received and sent packets" _absoluteAddress="0x1201810" name="counter_0">
    <hwreg width="32" sw="rw" counter="1" name="rcvd_pkts" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="sent_pkts" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields for discarded packets" _absoluteAddress="0x1201818" name="counter_1">
    <hwreg width="32" sw="rw" counter="1" name="wrong_desc" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="disabled_mbox" hw=""/>
   </reg64>
   <reg64 desc="This register that holds counter fields buffer queue requests and responses" _absoluteAddress="0x1201820" name="counter_2">
    <hwreg width="32" sw="rw" counter="1" name="bq_requests" hw=""/>
    <hwreg width="32" sw="rw" counter="1" name="bq_responses" hw=""/>
   </reg64>
   <reg64 desc="All useful information for debugging VELO are stored in this register" _absoluteAddress="0x1201828" name="debug_0">
    <hwreg width="3" desc="Current State of the Requester FSM" sw="ro" reset="3'b0" name="requester_state" hw="wo"/>
    <hwreg width="1" desc="indicates that the network port outport buffer is full" sw="ro" reset="1'b0" name="np_full" hw="wo"/>
    <hwreg width="5" desc="Current State of the Completer Fetch Stage FSM" sw="ro" reset="5'b0" name="completer_fetch_state" hw="wo"/>
    <hwreg width="5" desc="Current State of the Completer Dump Stage FSM" sw="ro" reset="5'b0" name="completer_dump_state" hw="wo"/>
    <hwreg width="1" desc="Indicates the release grant to HTAX was too early" sw="ro" reset="1'h0" name="eot_assertion" hw="wo"/>
    <hwreg width="1" desc="Indicates that a second SOP has been seen before and EOP" sw="ro" reset="1'h0" name="sop_assertion" hw="wo"/>
    <hwreg width="1" desc="Indicates that the VELO Completer Fetch Stage shifted into full address FIFO" sw="ro" reset="1'h0" name="addr_fifo_full_assert" hw="wo"/>
    <hwreg width="1" desc="Indicates that the VELO Completer Fetch Stage shifted into full data FIFO" sw="ro" reset="1'h0" name="data_fifo_full_assert" hw="wo"/>
    <hwreg width="1" desc="Indicates that the address FIFO between FETCH and DUMP is empty" sw="ro" reset="1'b0" name="addr_fifo_empty" hw="wo"/>
    <hwreg width="1" desc="Indicates that the data FIFO between FETCH and DUMP is empty" sw="ro" reset="1'b0" name="data_fifo_empty" hw="wo"/>
    <hwreg width="8" desc="Currently, from VELO Completer, targeted mailbox" sw="ro" reset="8'b0" name="target_mailbox" hw="wo"/>
   </reg64>
   <reg64 desc="All useful information for debugging VELO are stored in this register" _absoluteAddress="0x1201830" name="debug_1">
    <hwreg width="16" desc="Source Node of last detected error" sw="ro" reset="16'h0" name="error_snode" hw="wo"/>
    <hwreg width="8" desc="Source VPID of last detected error" sw="ro" reset="8'b0" name="error_svpid" hw="wo"/>
    <hwreg width="8" desc="Target VPID of last detected error" sw="ro" reset="8'b0" name="error_tvpid" hw="wo"/>
    <hwreg width="24" sw="rw" counter="1" name="error_count" hw=""/>
    <hwreg width="1" desc="Double bit error detected in one of the completer RAMs." sw="rw" reset="1'b0" name="completer_ram_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in one of the completer RAMs." sw="rw" reset="1'b0" name="completer_ram_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in one of the requester RAMs." sw="rw" reset="1'b0" name="requester_ram_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in one of the requester RAMs." sw="rw" reset="1'b0" name="requester_ram_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in the completer data fifo." sw="rw" reset="1'b0" name="completer_datafifo_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the completer data fifo." sw="rw" reset="1'b0" name="completer_datafifo_sec" hw="wo"/>
    <hwreg width="1" desc="Double bit error detected in the completer address fifo." sw="rw" reset="1'b0" name="completer_addressfifo_ded" hw="wo"/>
    <hwreg width="1" desc="Single bit error corrected in the completer address fifo." sw="rw" reset="1'b0" name="completer_addressfifo_sec" hw="wo"/>
   </reg64>
  </regroot>
  <regroot _baseAddress="0x1400000" _absoluteAddress="0x1400000" name="rma_rf">
   <regroot _baseAddress="0x1400000" _absoluteAddress="0x1400000" name="wcbuf_rf">
    <ramblock addrsize="8" ramwidth="64" sw="rw" addr_shift="9" _absoluteAddress="0x1400000" name="state" external="1" hw="rw">
     <field width="24" name="commited_packet_counter"/>
     <field width="8" name="current_packet_length"/>
     <field width="1" name="retry_bit"/>
     <field width="1" name="assembly_full_bit"/>
     <field width="1" name="streamout_full_bit"/>
     <field width="5" name="reserved1"/>
     <field width="8" name="word_count"/>
     <field width="8" name="reserved2"/>
     <field width="8" name="retry_packet_count"/>
    </ramblock>
    <reg64 desc="This register is used to control timeout of incoming requests at the Write-Combining-Buffer. Also the forwarding latency can be tuned" _absoluteAddress="0x1500000" name="timeout">
     <hwreg width="1" desc="This is an enable flag for the timeout functioniality. Only if this bit is set, timeout may occur, otherwise the WCB may wait infinitely." sw="rw" reset="1'b0" name="timeout_active" hw="ro"/>
     <hwreg width="1" desc="Is set, the latency counter feature is used, otherwise packet data is forwarded to the streamout stage when the packet has been completely received (store-and-forward mode)." sw="rw" reset="1'b0" name="lat_counter_enable" hw="ro"/>
     <reserved width="6"/>
     <hwreg width="8" desc="This is the number of cycles waited after a packet is seen to complete in the assembly stage before control information is forwarded to the streamout stage." sw="rw" reset="8'hff" name="lat_counter_value" hw="ro"/>
     <reserved width="16"/>
     <hwreg width="32" desc="The timeout threshold. Gives the number of cycles that should be waited before going into retry state." sw="rw" reset="32'b0" name="timeout" hw="ro"/>
    </reg64>
    <reg64 desc="Error flags of the WCB" _absoluteAddress="0x1500008" name="errors0">
     <hwreg width="24" desc="Incremented whenever a HTOC packet is not quadword sized." sw="rw" counter="1" name="qw_length_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest qw length error." sw="rw" reset="8'b0" name="qw_length_error_vpid" hw="wo"/>
     <hwreg width="24" desc="Incremented whenever a message is too long for this WCB." sw="rw" counter="1" name="msg_too_long_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest message too long error." sw="rw" reset="8'b0" name="msg_too_long_vpid" hw="wo"/>
    </reg64>
    <reg64 desc="Error flags of the WCB" _absoluteAddress="0x1500010" name="errors1">
     <hwreg width="24" desc="Incremented whenever a HTOC packet is not qword aligned, that arrives at the wcbuf." sw="rw" counter="1" name="msg_not_aligned_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest packet not aligned error." sw="rw" reset="8'b0" name="msg_not_alinged_vpid" hw="wo"/>
     <hwreg width="24" desc="Incremented whenever a HTOC packet is too long for this WCB." sw="rw" counter="1" name="pkt_too_long_error" hw=""/>
     <hwreg width="8" desc="VPID of the request that caused the latest packet too long error." sw="rw" reset="8'b0" name="pkt_too_long_vpid" hw="wo"/>
    </reg64>
    <reg64 desc="This register controls the  WCB Event Mirroring facility, i.e. if and how status changes are reflected to main memory." _absoluteAddress="0x1500018" name="event_mirror">
     <hwreg width="8" desc="This bit gives the condition, when the packet counter is mirrored to main memory. One bit should be set to one. If this bit toggles, the value in main memory is updated. Set this register to 0 to disable mirroring of counter updates. For example, if bit 4 is set, every 16 requests the counter is mirrored to main memory." sw="rw" reset="8'b0" name="commited_packet_mirror_mask" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes of the retry counter." sw="rw" reset="1'b0" name="enable_mirror_retrycounter" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes to the commited packet counter (if enabled)." sw="rw" reset="1'b0" name="enable_update_commited_packets" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of changes that were performed by software by writing to the state block." sw="rw" reset="1'b0" name="enable_update_sw" hw="ro"/>
     <hwreg width="1" desc="Enable/disabled mirroring of updates to the retry status bit. Can save SW the work to save rejected packet count to main-memory/read from device." sw="rw" reset="1'b0" name="enable_mirror_retried" hw="ro"/>
     <hwreg width="52" desc="Main memory base address, where status updates are mirrored to. One page per VPID needed. In this page, a single quadword with offset 0 is used as target of the status updates." sw="rw" reset="52'b0" name="status_mirror_base" hw="ro"/>
    </reg64>
    <reg64 desc="The base address register for the WCB Packet Mirroring facility, i.e. if and how discarded packets are reflected to main memory." _absoluteAddress="0x1500020" name="retry_mirror_base">
     <hwreg width="1" desc="Enable/disabled mirroring of discarded packets." sw="rw" reset="1'b0" name="packet_enable_mirror" hw="ro"/>
     <hwreg width="8" desc="This register encodes the sizse of the mirror region in entries per VPID. Mask/thermocode is used. if all 1s, this means 256 entries per VPID are enabled. An entry has maximum message size, i.e. 32byte for RMA which translates to 2 MB of physical memory with 256 entries. and 8 MB for VELO2" sw="rw" reset="8'b0" name="packet_mirror_size" hw="ro"/>
     <reserved width="3"/>
     <hwreg width="52" desc="This registers holds the base address of the area where discarded packets are mirrored to. One page per VPID is needed. How large the actual region is (within this page) used to store packets is determined by the mirror_size field. Note, that this field holds the physical address, without page offset. If the packet_mirror_size is larger than 5'b11111, more than one page is needed per VPID in the VELO2 case, than the address has to be aligned accordingly." sw="rw" reset="52'b0" name="packet_mirror_base" hw="ro"/>
    </reg64>
    <reg64 desc="This register holds all of the ECC status information from the WCBUF RAM Buffers" _absoluteAddress="0x1500028" name="ecc_status">
     <hwreg width="1" desc="Double error deteced in wcbuf state rams." sw="rw" reset="1'b0" name="state_ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf state rams." sw="rw" reset="1'b0" name="state_ram_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf assembly buffer ram." sw="rw" reset="1'b0" name="buffer_ram_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf assembly buffer ram." sw="rw" reset="1'b0" name="buffer_ram_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf datain fifo ram." sw="rw" reset="1'b0" name="datain_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf datain fifo ram." sw="rw" reset="1'b0" name="datain_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf ctlin fifo ram." sw="rw" reset="1'b0" name="ctlin_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf ctlin fifo ram." sw="rw" reset="1'b0" name="ctlin_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf assembled_queue fifo ram." sw="rw" reset="1'b0" name="assembled_queue_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf assembled_queue fifo ram." sw="rw" reset="1'b0" name="assembled_queue_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf dataout fifo ram." sw="rw" reset="1'b0" name="dataout_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf dataout fifo ram." sw="rw" reset="1'b0" name="dataout_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf rdy_queue fifo ram." sw="rw" reset="1'b0" name="rdy_queue_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf rdy_queue fifo ram." sw="rw" reset="1'b0" name="rdy_queue_fifo_sec" hw="wo"/>
     <hwreg width="1" desc="Double error deteced in wcbuf mirror fifo ram." sw="rw" reset="1'b0" name="mirror_fifo_ded" hw="wo"/>
     <hwreg width="1" desc="Single error corrected in wcbuf mirror fifo ram." sw="rw" reset="1'b0" name="mirror_fifo_sec" hw="wo"/>
    </reg64>
   </regroot>
   <regroot _baseAddress="0x1600000" _absoluteAddress="0x1600000" name="noti_interrupt_handler">
    <reg64 _absoluteAddress="0x1600000" name="int_ctrl">
     <hwreg width="1" desc="Changes on this register initiate an SNQ trigger event." sw="" reset="1'b0" name="toggle" hw="wo"/>
    </reg64>
    <ramblock addrsize="2" ramwidth="64" sw="ro" _absoluteAddress="0x1600020" name="int_vec" external="1" hw="rw"/>
    <ramblock addrsize="2" ramwidth="64" sw="rw" _absoluteAddress="0x1600040" name="int_retrig_vec" external="1" hw="rw"/>
   </regroot>
   <reg64 desc="Contains sizing information about the memory region where the LOCK variables are stored. The doubleword address for a lock variable is calculated by lock_base_address + lock_number*vpids + vpid. The maximum amount of vpids is a hardware constant, and is implementation specific." _absoluteAddress="0x1600080" name="config">
    <hwreg width="10" desc="The configurable maximum transfer unit (MTU) that is used by the RMA units. 0 means 0 for this field. Specified in byte. Must be a multiple of 16. Minimum is 32. The maximum payload size is this value -16 byte (RMA PUT Req/GET Resp network header)" sw="rw" reset="10'h040" name="mtu" hw="ro"/>
    <reserved width="6"/>
    <hwreg width="4" desc="This field relates to the host interface usage. A value of 0x0 means that RMA operates under the assumption of HyperTransport being the host interface. This means that host sided requests have a maximum payload size of 64 byte. 0x1 means that the host interface is PCIe, but the maximum payload size remains 64 byte. 0x2 means host interface is PCIe and maximum payload size is 128 byte. 0x4 means that host interface is PCIe and maximum transfer size is 256 byte. All other values may result in unspecified operation! This register affects the payload writes of the RMA Completer." sw="rw" reset="4'b0" name="pcie_mode" hw="ro"/>
    <hwreg width="4" desc="This field relates to the host interface usage. A value of 0x0 means that RMA reads operate under the assumption of HyperTransport being the host interface. This means that host sided read requests have a maximum request size of 64 byte. Any value > 0 indicates that PCIe is the host interface and this register defines the maximum (read) request size of the PCIe system. 0x1 means that the host interface is PCIe, and the maximum request size is 64 byte. 0x2 means host interface is PCIe and maximum request size is 128 byte. 0x4 means that host interface is PCIe and maximum request size is 256 byte. 0x8 means that the host interface is PCIe and the maximum request size is 512 byte. All other values may result in unspecified operation! This register affects the RMA Responder and RMA Requester." sw="rw" reset="4'b0" name="pcie_mode_reads" hw="ro"/>
    <reserved width="8"/>
    <hwreg width="1" desc="Force Error Notifications: If this field is set then all errors that do not cause the packets to get dropped, will write notifications and be forwarded to write notifications in other units." sw="rw" reset="1'b0" name="fen" hw="ro"/>
    <hwreg width="1" desc="Read Engine PassPW Disable: Forbids from setting the PassPW bit for any read request. If not set the Read Engines will use PassPW except for LOCK related reads." sw="rw" reset="1'b0" name="repd" hw="ro"/>
   </reg64>
   <reg64 desc="Contains the physical base address that the RMA responder uses to access the LOCK variables." _absoluteAddress="0x1600088" name="lock_base">
    <reserved width="12"/>
    <hwreg width="52" desc="The upper 52 bit of the base address for all lock values. Must be 4kB page aligned, which means lower 12 bit are 0!" sw="rw" reset="52'b0" name="address" hw="ro"/>
   </reg64>
   <reg64 desc="Contains sizing information about the memory region where the LOCK variables are stored. The doubleword address for a lock variable is calculated by lock_base_address + lock_number*vpids + vpid. The maximum amount of vpids is a hardware constant, and is implementation specific." _absoluteAddress="0x1600090" name="lock_cfg">
    <hwreg width="25" desc="Number of existing LOCK variables for each VPID. 0 means 0 with this counter. The maximum allowed lock number is 2^24!" sw="rw" reset="25'b0" name="number_allowed" hw="ro"/>
    <reserved width="6"/>
    <hwreg width="10" desc="Number of existing VPIDs. 0 means 0 with this counter. Depending on the hardware implementation not all 10 bits might be supported." sw="rw" reset="10'b0" name="vpids_allowed" hw="ro"/>
    <reserved width="6"/>
    <hwreg width="8" desc="This defines the PCIe steering tag used by the RMA responder to write back LOCK values." sw="rw" reset="8'b0" name="steertag" hw="ro"/>
    <hwreg width="2" desc="This defines the PCIe TLP processing hint setting used by the RMA responder to write back LOCK values." sw="rw" reset="2'b0" name="tph" hw="ro"/>
    <hwreg width="1" desc="This defines the PCIe TLP hint setting used by the RMA responder to write back LOCK values." sw="rw" reset="1'b0" name="th" hw="ro"/>
   </reg64>
   <reg64 desc="Contains the BQ timeout value and timeout enable." _absoluteAddress="0x1600098" name="bq_timeout">
    <hwreg width="32" desc="Defines the timeout value in Extoll internal cycles." sw="rw" reset="32'b0" name="value" hw="ro"/>
    <hwreg width="1" desc="Set to enable to BQ timeout mechanism." sw="rw" reset="1'b0" name="enable" hw="ro"/>
   </reg64>
   <ramblock addrsize="8" ramwidth="43" sw="rw" _absoluteAddress="0x1600800" name="vpid_table" external="1" hw="ro">
    <field width="1" name="vpid_en"/>
    <field width="3" name="tu_compl"/>
    <field width="3" name="tu_resp"/>
    <field width="1" name="excell_en"/>
    <field width="2" name="tc0"/>
    <field width="2" name="tc1"/>
    <field width="2" name="tc2"/>
    <field width="2" name="tc3"/>
    <field width="16" name="pdid"/>
    <field width="8" name="steertag"/>
    <field width="2" name="tph"/>
    <field width="1" name="th"/>
   </ramblock>
   <reg64 desc="Contains control options for the RMA requester's error reporting." _absoluteAddress="0x1601000" name="requester_error_ctrl">
    <hwreg width="1" desc="The error history structure stores the last n errors if mode=0. It stores the first n errors if mode=1." sw="rw" reset="1'b0" name="history_mode" hw="ro"/>
    <hwreg width="1" desc="Writing a 1 to this field will cause a reset of all history entries. Field is self-clearing. While the structure is being cleared, new errors migth not get logged." sw="rw" reset="1'b0" name="history_clear" hw="rw"/>
    <hwreg width="1" desc="Writing a 1 to this field will reset all error counters. Field is self-clearing." sw="rw" reset="1'b0" name="counts_clear" hw="rw"/>
    <reserved width="5"/>
    <hwreg width="10" desc="Specifies how many entries currently reside in the history structure." sw="ro" reset="10'b0" name="history_cnt" hw="wo"/>
    <reserved width="6"/>
    <hwreg width="1" desc="Used by the hardware to trigger a dump of the error history structure." sw="" reset="1'b0" name="history_trigger" hw="wo"/>
   </reg64>
   <ramblock addrsize="0" ramwidth="64" sw="ro" _absoluteAddress="0x1601008" name="requester_history" external="1" hw="rw">
    <field width="9" name="error_vpid_loc"/>
    <field width="9" name="error_vpid_rem"/>
    <field width="16" name="error_node_rem"/>
    <field width="1" name="error_0_exlreg"/>
    <field width="1" name="error_1_cmdt"/>
    <field width="1" name="error_2_exldis"/>
    <field width="1" name="error_3_trans"/>
    <field width="1" name="error_4_bqt"/>
    <field width="24" name="reserved"/>
    <field width="1" name="valid"/>
   </ramblock>
   <reg64 desc="" _absoluteAddress="0x1601010" name="requester_error_cnt_st">
    <hwreg width="1" desc="Used to trigger the SNQ whenever one of the RMA Requester error counters has changed" sw="ro" reset="1'b0" name="trigger" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA requester unit." _absoluteAddress="0x1601018" name="requester_error_cnt_0">
    <hwreg width="15" desc="Counts how often a EXLREG error condition occurred." sw="ro" reset="15'b0" name="count_exlreg" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLREG counter has overflown." sw="ro" reset="1'b0" name="ovflw_exlreg" hw="wo"/>
    <hwreg width="15" desc="Counts how often a CMDT error condition occurred." sw="ro" reset="15'b0" name="count_cmdt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the CMDT counter has overflown." sw="ro" reset="1'b0" name="ovflw_cmdt" hw="wo"/>
    <hwreg width="15" desc="Counts how often a EXLDIS error condition occurred." sw="ro" reset="15'b0" name="count_exldis" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLDIS counter has overflown." sw="ro" reset="1'b0" name="ovflw_exldis" hw="wo"/>
    <hwreg width="15" desc="Counts how often a TRANS error condition occurred." sw="ro" reset="15'b0" name="count_trans" hw="wo"/>
    <hwreg width="1" desc="Indicates that the TRANS counter has overflown." sw="ro" reset="1'b0" name="ovflw_trans" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA requester unit." _absoluteAddress="0x1601020" name="requester_error_cnt_1">
    <hwreg width="15" desc="Counts how often a BQT error condition occurred." sw="ro" reset="15'b0" name="count_bqt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the BQT counter has overflown." sw="ro" reset="1'b0" name="ovflw_bqt" hw="wo"/>
   </reg64>
   <reg64 desc="Contains control options for the RMA responder's error reporting." _absoluteAddress="0x1601028" name="responder_error_ctrl">
    <hwreg width="1" desc="The error history structure stores the last n errors if mode=0. It stores the first n errors if mode=1." sw="rw" reset="1'b0" name="history_mode" hw="ro"/>
    <hwreg width="1" desc="Writing a 1 to this field will cause a reset of all history entries. Field is self-clearing. While the structure is being cleared, new errors migth not get logged." sw="rw" reset="1'b0" name="history_clear" hw="rw"/>
    <hwreg width="1" desc="Writing a 1 to this field will reset all error counters. Field is self-clearing." sw="rw" reset="1'b0" name="counts_clear" hw="rw"/>
    <reserved width="5"/>
    <hwreg width="10" desc="Specifies how many entries currently reside in the history structure." sw="ro" reset="10'b0" name="history_cnt" hw="wo"/>
    <reserved width="6"/>
    <hwreg width="1" desc="Used by the hardware to trigger a dump of the error history structure." sw="" reset="1'b0" name="history_trigger" hw="wo"/>
   </reg64>
   <ramblock addrsize="0" ramwidth="64" sw="ro" _absoluteAddress="0x1601030" name="responder_history" external="1" hw="rw">
    <field width="9" name="error_vpid_loc"/>
    <field width="9" name="error_vpid_rem"/>
    <field width="16" name="error_node_rem"/>
    <field width="1" name="error_0_exlreg"/>
    <field width="1" name="error_1_cmdt"/>
    <field width="1" name="error_2_errcmd"/>
    <field width="1" name="error_3_vpid"/>
    <field width="1" name="error_4_pdid"/>
    <field width="1" name="error_5_exldis"/>
    <field width="1" name="error_6_lock"/>
    <field width="1" name="error_7_trans"/>
    <field width="1" name="error_8_bqt"/>
    <field width="20" name="reserved"/>
    <field width="1" name="valid"/>
   </ramblock>
   <reg64 desc="" _absoluteAddress="0x1601038" name="responder_error_cnt_st">
    <hwreg width="1" desc="Used to trigger the SNQ whenever one of the RMA Responder error counters has changed" sw="ro" reset="1'b0" name="trigger" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA responder unit." _absoluteAddress="0x1601040" name="responder_error_cnt_0">
    <hwreg width="15" desc="Counts how often a EXLREG error condition occurred." sw="ro" reset="15'b0" name="count_exlreg" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLREG counter has overflown." sw="ro" reset="1'b0" name="ovflw_exlreg" hw="wo"/>
    <hwreg width="15" desc="Counts how often a CMDT error condition occurred." sw="ro" reset="15'b0" name="count_cmdt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the CMDT counter has overflown." sw="ro" reset="1'b0" name="ovflw_cmdt" hw="wo"/>
    <hwreg width="15" desc="Counts how often a ERRCMD error condition occurred." sw="ro" reset="15'b0" name="count_errcmd" hw="wo"/>
    <hwreg width="1" desc="Indicates that the ERRCMD counter has overflown." sw="ro" reset="1'b0" name="ovflw_errcmd" hw="wo"/>
    <hwreg width="15" desc="Counts how often a VPID error condition occurred." sw="ro" reset="15'b0" name="count_vpid" hw="wo"/>
    <hwreg width="1" desc="Indicates that the VPID counter has overflown." sw="ro" reset="1'b0" name="ovflw_vpid" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA responder unit." _absoluteAddress="0x1601048" name="responder_error_cnt_1">
    <hwreg width="15" desc="Counts how often a PDID error condition occurred." sw="ro" reset="15'b0" name="count_pdid" hw="wo"/>
    <hwreg width="1" desc="Indicates that the PDID counter has overflown." sw="ro" reset="1'b0" name="ovflw_pdid" hw="wo"/>
    <hwreg width="15" desc="Counts how often a EXLDIS error condition occurred." sw="ro" reset="15'b0" name="count_exldis" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLDIS counter has overflown." sw="ro" reset="1'b0" name="ovflw_exldis" hw="wo"/>
    <hwreg width="15" desc="Counts how often a LOCK error condition occurred." sw="ro" reset="15'b0" name="count_lock" hw="wo"/>
    <hwreg width="1" desc="Indicates that the LOCK counter has overflown." sw="ro" reset="1'b0" name="ovflw_lock" hw="wo"/>
    <hwreg width="15" desc="Counts how often a TRANS error condition occurred." sw="ro" reset="15'b0" name="count_trans" hw="wo"/>
    <hwreg width="1" desc="Indicates that the TRANS counter has overflown." sw="ro" reset="1'b0" name="ovflw_trans" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA responder unit." _absoluteAddress="0x1601050" name="responder_error_cnt_2">
    <hwreg width="15" desc="Counts how often a BQT error condition occurred." sw="ro" reset="15'b0" name="count_bqt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the BQT counter has overflown." sw="ro" reset="1'b0" name="ovflw_bqt" hw="wo"/>
   </reg64>
   <reg64 desc="Contains control options for the RMA completer's error reporting." _absoluteAddress="0x1601058" name="completer_error_ctrl">
    <hwreg width="1" desc="The error history structure stores the last n errors if mode=0. It stores the first n errors if mode=1." sw="rw" reset="1'b0" name="history_mode" hw="ro"/>
    <hwreg width="1" desc="Writing a 1 to this field will cause a reset of all history entries. Field is self-clearing. While the structure is being cleared, new errors migth not get logged." sw="rw" reset="1'b0" name="history_clear" hw="rw"/>
    <hwreg width="1" desc="Writing a 1 to this field will reset all error counters. Field is self-clearing." sw="rw" reset="1'b0" name="counts_clear" hw="rw"/>
    <reserved width="5"/>
    <hwreg width="10" desc="Specifies how many entries currently reside in the history structure." sw="ro" reset="10'b0" name="history_cnt" hw="wo"/>
    <reserved width="6"/>
    <hwreg width="1" desc="Used by the hardware to trigger a dump of the error history structure." sw="" reset="1'b0" name="history_trigger" hw="wo"/>
   </reg64>
   <ramblock addrsize="0" ramwidth="64" sw="ro" _absoluteAddress="0x1601060" name="completer_history" external="1" hw="rw">
    <field width="9" name="error_vpid_loc"/>
    <field width="9" name="error_vpid_rem"/>
    <field width="16" name="error_node_rem"/>
    <field width="1" name="error_0_exlreg"/>
    <field width="1" name="error_1_cmdt"/>
    <field width="1" name="error_2_nosop"/>
    <field width="1" name="error_3_hdrshrt"/>
    <field width="1" name="error_4_nodat"/>
    <field width="1" name="error_5_fewdat"/>
    <field width="1" name="error_6_moredat"/>
    <field width="1" name="error_7_errcmd"/>
    <field width="1" name="error_8_vpid"/>
    <field width="1" name="error_9_pdid"/>
    <field width="1" name="error_10_exldis"/>
    <field width="1" name="error_11_trans"/>
    <field width="1" name="error_12_bqt"/>
    <field width="16" name="reserved"/>
    <field width="1" name="valid"/>
   </ramblock>
   <reg64 desc="" _absoluteAddress="0x1601068" name="completer_error_cnt_st">
    <hwreg width="1" desc="Used to trigger the SNQ whenever one of the RMA Completer error counters has changed" sw="ro" reset="1'b0" name="trigger" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA completer unit." _absoluteAddress="0x1601070" name="completer_error_cnt_0">
    <hwreg width="15" desc="Counts how often a EXLREG error condition occurred." sw="ro" reset="15'b0" name="count_exlreg" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLREG counter has overflown." sw="ro" reset="1'b0" name="ovflw_exlreg" hw="wo"/>
    <hwreg width="15" desc="Counts how often a CMDT error condition occurred." sw="ro" reset="15'b0" name="count_cmdt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the CMDT counter has overflown." sw="ro" reset="1'b0" name="ovflw_cmdt" hw="wo"/>
    <hwreg width="15" desc="Counts how often a NOSOP error condition occurred." sw="ro" reset="15'b0" name="count_nosop" hw="wo"/>
    <hwreg width="1" desc="Indicates that the NOSOP counter has overflown." sw="ro" reset="1'b0" name="ovflw_nosop" hw="wo"/>
    <hwreg width="15" desc="Counts how often a HDRSHRT error condition occurred." sw="ro" reset="15'b0" name="count_hdrshrt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the HDRSHRT counter has overflown." sw="ro" reset="1'b0" name="ovflw_hdrshrt" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA completer unit." _absoluteAddress="0x1601078" name="completer_error_cnt_1">
    <hwreg width="15" desc="Counts how often a NODAT error condition occurred." sw="ro" reset="15'b0" name="count_nodat" hw="wo"/>
    <hwreg width="1" desc="Indicates that the NODAT counter has overflown." sw="ro" reset="1'b0" name="ovflw_nodat" hw="wo"/>
    <hwreg width="15" desc="Counts how often a FEWDAT error condition occurred." sw="ro" reset="15'b0" name="count_fewdat" hw="wo"/>
    <hwreg width="1" desc="Indicates that the FEWDAT counter has overflown." sw="ro" reset="1'b0" name="ovflw_fewdat" hw="wo"/>
    <hwreg width="15" desc="Counts how often a MOREDAT error condition occurred." sw="ro" reset="15'b0" name="count_moredat" hw="wo"/>
    <hwreg width="1" desc="Indicates that the MOREDAT counter has overflown." sw="ro" reset="1'b0" name="ovflw_moredat" hw="wo"/>
    <hwreg width="15" desc="Counts how often a ERRCMD error condition occurred." sw="ro" reset="15'b0" name="count_errcmd" hw="wo"/>
    <hwreg width="1" desc="Indicates that the ERRCMD counter has overflown." sw="ro" reset="1'b0" name="ovflw_errcmd" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA completer unit." _absoluteAddress="0x1601080" name="completer_error_cnt_2">
    <hwreg width="15" desc="Counts how often a VPID error condition occurred." sw="ro" reset="15'b0" name="count_vpid" hw="wo"/>
    <hwreg width="1" desc="Indicates that the VPID counter has overflown." sw="ro" reset="1'b0" name="ovflw_vpid" hw="wo"/>
    <hwreg width="15" desc="Counts how often a PDID error condition occurred." sw="ro" reset="15'b0" name="count_pdid" hw="wo"/>
    <hwreg width="1" desc="Indicates that the PDID counter has overflown." sw="ro" reset="1'b0" name="ovflw_pdid" hw="wo"/>
    <hwreg width="15" desc="Counts how often a EXLDIS error condition occurred." sw="ro" reset="15'b0" name="count_exldis" hw="wo"/>
    <hwreg width="1" desc="Indicates that the EXLDIS counter has overflown." sw="ro" reset="1'b0" name="ovflw_exldis" hw="wo"/>
    <hwreg width="15" desc="Counts how often a TRANS error condition occurred." sw="ro" reset="15'b0" name="count_trans" hw="wo"/>
    <hwreg width="1" desc="Indicates that the TRANS counter has overflown." sw="ro" reset="1'b0" name="ovflw_trans" hw="wo"/>
   </reg64>
   <reg64 desc="Holds a part of the error counters of the RMA completer unit." _absoluteAddress="0x1601088" name="completer_error_cnt_3">
    <hwreg width="15" desc="Counts how often a BQT error condition occurred." sw="ro" reset="15'b0" name="count_bqt" hw="wo"/>
    <hwreg width="1" desc="Indicates that the BQT counter has overflown." sw="ro" reset="1'b0" name="ovflw_bqt" hw="wo"/>
   </reg64>
   <reg64 desc="Contains information about corrected single errors and detected double errors for different RMA modules." _absoluteAddress="0x1601090" name="error_ram_ecc">
    <hwreg width="1" desc="A single bit error was corrected inside the VPID table RAM instance." sw="rw" reset="1'b0" name="vpid_table_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 2nd stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage2_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 3rd stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage3_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 4th stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage4_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance of the ReadEngine in the RMA Requester." sw="rw" reset="1'b0" name="requester_readengine_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 1st stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage1_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 2nd stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage2_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 3rd stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage3_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 4th stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage4_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance in the 5th stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage5_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside a RAM instance of the ReadEngine in the RMA Responder." sw="rw" reset="1'b0" name="responder_readengine_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the Stream buffer of the RMA Completer." sw="rw" reset="1'b0" name="completer_streambuf_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the StreamControl buffer of the RMA Completer." sw="rw" reset="1'b0" name="completer_streamcont_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the VPID Check module of the RMA Completer." sw="rw" reset="1'b0" name="completer_vpidcheck_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the Lock Order module of the RMA Completer." sw="rw" reset="1'b0" name="completer_lockorder_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the ATU Handler module of the RMA Completer." sw="rw" reset="1'b0" name="completer_handleratu_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the RF Reader module of the RMA Completer." sw="rw" reset="1'b0" name="completer_rfreader_sec" hw="wo"/>
    <hwreg width="1" desc="A single bit error was corrected inside the BQ Handler module of the RMA Completer." sw="rw" reset="1'b0" name="completer_handlerbq_sec" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the VPID table RAM instance." sw="rw" reset="1'b0" name="vpid_table_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 2nd stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage2_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 3rd stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage3_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 4th stage of the RMA Requester." sw="rw" reset="1'b0" name="requester_stage4_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance of the ReadEngine in the RMA Requester." sw="rw" reset="1'b0" name="requester_readengine_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 1st stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage1_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 2nd stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage2_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 3rd stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage3_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 4th stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage4_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance in the 5th stage of the RMA Responder." sw="rw" reset="1'b0" name="responder_stage5_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside a RAM instance of the ReadEngine in the RMA Responder." sw="rw" reset="1'b0" name="responder_readengine_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the Stream buffer of the RMA Completer." sw="rw" reset="1'b0" name="completer_streambuf_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the StreamControl buffer of the RMA Completer." sw="rw" reset="1'b0" name="completer_streamcont_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the VPID Check module of the RMA Completer." sw="rw" reset="1'b0" name="completer_vpidcheck_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the Lock Order module of the RMA Completer." sw="rw" reset="1'b0" name="completer_lockorder_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the ATU Handler module of the RMA Completer." sw="rw" reset="1'b0" name="completer_handleratu_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the RF Reader module of the RMA Completer." sw="rw" reset="1'b0" name="completer_rfreader_ded" hw="wo"/>
    <hwreg width="1" desc="A double bit error was detected inside the BQ Handler module of the RMA Completer." sw="rw" reset="1'b0" name="completer_handlerbq_ded" hw="wo"/>
   </reg64>
   <regroot _baseAddress="0x1601200" _absoluteAddress="0x1601200" name="perf">
    <reg64 _absoluteAddress="0x1601200" name="counter_control">
     <rreinit/>
    </reg64>
    <reg64 desc="Requester host (HT/PCIe) input performance counters. (part 0)" _absoluteAddress="0x1601208" name="requester_perf_in_0">
     <hwreg width="32" desc="Number of received QW PUT requests." sw="ro" counter="1" name="put_qw" hw=""/>
     <hwreg width="32" desc="Number of received Byte PUT requests." sw="ro" counter="1" name="put_byte" hw=""/>
    </reg64>
    <reg64 desc="Requester host (HT/PCIe) input performance counters. (part 1)" _absoluteAddress="0x1601210" name="requester_perf_in_1">
     <hwreg width="32" desc="Number of received Immediate PUT requests." sw="ro" counter="1" name="put_imm" hw=""/>
     <hwreg width="32" desc="Number of received notification PUT requests" sw="ro" counter="1" name="put_noti" hw=""/>
    </reg64>
    <reg64 desc="Requester host (HT/PCIe) input performance counters. (part 2)" _absoluteAddress="0x1601218" name="requester_perf_in_2">
     <hwreg width="32" desc="Number of received QW GET requests." sw="ro" counter="1" name="get_qw" hw=""/>
     <hwreg width="32" desc="Number of received Byte GET requests." sw="ro" counter="1" name="get_byte" hw=""/>
    </reg64>
    <reg64 desc="Requester host (HT/PCIe) input performance counters. (part 3)" _absoluteAddress="0x1601220" name="requester_perf_in_3">
     <hwreg width="32" desc="Number of received LOCK requests targeting the Responder." sw="ro" counter="1" name="lock_resp" hw=""/>
     <hwreg width="32" desc="Number of received LOCK requests targeting the Completer." sw="ro" counter="1" name="lock_compl" hw=""/>
    </reg64>
    <reg64 desc="Requester ATU related performance counters. (part 0)" _absoluteAddress="0x1601228" name="requester_perf_atu_0">
     <hwreg width="32" desc="Number of requested address translations" sw="ro" counter="1" name="trans_req" hw=""/>
     <hwreg width="32" desc="Number of received successful translations." sw="ro" counter="1" name="trans_rcvd" hw=""/>
    </reg64>
    <reg64 desc="Requester ATU related performance counters. (part 1)" _absoluteAddress="0x1601230" name="requester_perf_atu_1">
     <hwreg width="32" desc="Number of received failed translations, or translations that did not return the correct access type." sw="ro" counter="1" name="trans_rcvd_err" hw=""/>
    </reg64>
    <reg64 desc="Requester ATU related performance counters. (part 2)" _absoluteAddress="0x1601238" name="requester_perf_atu_2">
     <hwreg width="32" desc="Fence requests received from the ATU instance." sw="ro" counter="1" name="fence_rcvd" hw=""/>
     <hwreg width="32" desc="Fence responses sent back to the ATU instance." sw="ro" counter="1" name="fence_answd" hw=""/>
    </reg64>
    <reg64 desc="Requester read engine related performance counters. (part 0)" _absoluteAddress="0x1601240" name="requester_perf_re_0">
     <hwreg width="32" desc="Read requests issued towards the host interface." sw="ro" counter="1" name="rd_req" hw=""/>
    </reg64>
    <reg64 desc="Requester read engine related performance counters. (part 1)" _absoluteAddress="0x1601248" name="requester_perf_re_1">
     <hwreg width="48" desc="How much data (in bytes) has been requested from the host interface. Important: Byte requests are not used for reads, so even if only 1 byte was to be accessed, this will result in a 4 byte host interface access! Similarly non-aligned addresses can cause more data to be read than is actually needed for the request. Writes clear this register." sw="rw" reset="48'b0" name="byte_req" hw="wo"/>
    </reg64>
    <reg64 desc="Requester read engine related performance counters. (part 2)" _absoluteAddress="0x1601250" name="requester_perf_re_2">
     <hwreg width="32" desc="Number of read responses received from the host interface." sw="ro" counter="1" name="rd_resp" hw=""/>
     <hwreg width="32" desc="Number of erroneous read responses received from the host interface." sw="ro" counter="1" name="rd_resp_err" hw=""/>
    </reg64>
    <reg64 desc="Requester read engine related performance counters. (part 3)" _absoluteAddress="0x1601258" name="requester_perf_re_3">
     <hwreg width="48" desc="How much data (in bytes) has been received from the host interface. Important: Byte requests are not used for reads, so even if only 1 byte was to be accessed, this will result in a 4 byte host interface access! Similarly non-aligned addresses can cause more data to be read than is actually needed for the request. Writes clear this register." sw="rw" reset="48'b0" name="byte_rcvd" hw="wo"/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 0)" _absoluteAddress="0x1601260" name="requester_perf_out_0">
     <hwreg width="32" desc="Number of QW PUT requests forwarded to the network interface." sw="ro" counter="1" name="put_qw" hw=""/>
     <hwreg width="32" desc="Number of Byte PUT requests forwarded to the network interface." sw="ro" counter="1" name="put_byte" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 1)" _absoluteAddress="0x1601268" name="requester_perf_out_1">
     <hwreg width="32" desc="Number of Immediate PUT requests forwarded to the network interface." sw="ro" counter="1" name="put_imm" hw=""/>
     <hwreg width="32" desc="Number of notification PUT requests forwarded to the network interface." sw="ro" counter="1" name="put_noti" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 2)" _absoluteAddress="0x1601270" name="requester_perf_out_2">
     <hwreg width="32" desc="Number of QW GET requests forwarded to the network interface." sw="ro" counter="1" name="get_qw" hw=""/>
     <hwreg width="32" desc="Number of Byte GET requests forwarded to the network interface." sw="ro" counter="1" name="get_byte" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 3)" _absoluteAddress="0x1601278" name="requester_perf_out_3">
     <hwreg width="32" desc="Number of LOCK requests tageting the responder forwarded to the network interface." sw="ro" counter="1" name="lock_resp" hw=""/>
     <hwreg width="32" desc="Number of LOCK requests tageting the completer forwarded to the network interface." sw="ro" counter="1" name="lock_compl" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 4)" _absoluteAddress="0x1601280" name="requester_perf_out_4">
     <hwreg width="32" desc="Number of requests that were not forwarded to the network interface, but did require a notification." sw="ro" counter="1" name="not" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 5)" _absoluteAddress="0x1601288" name="requester_perf_out_5">
     <hwreg width="48" desc="Cycles in which any kind of information (header or data) was forwarded to the network interface. Includes SOP." sw="ro" counter="1" name="np_cycle" hw=""/>
    </reg64>
    <reg64 desc="Requester network interface performance counters. (part 6)" _absoluteAddress="0x1601290" name="requester_perf_out_6">
     <hwreg width="48" desc="How much data (in bytes) has been forwarded to the network interface. Includes QW, Byte and Immediate PUT data bytes. This count specifies the amount of valid payload, even though the actual payload is always a multiple of 64 bit. Writes clear this register." sw="rw" reset="48'b0" name="byte_sent" hw="wo"/>
    </reg64>
    <reg64 desc="Requester notification performance counters." _absoluteAddress="0x1601298" name="requester_perf_noti">
     <hwreg width="32" desc="Total number of sent notifications." sw="ro" counter="1" name="send" hw=""/>
     <hwreg width="32" desc="Number of notifications which were marked as interrupt." sw="ro" counter="1" name="int" hw=""/>
    </reg64>
    <reg64 desc="Responder network input performance counters. (part 0)" _absoluteAddress="0x16012a0" name="responder_perf_in_0">
     <hwreg width="32" desc="Number of received QW GET requests." sw="ro" counter="1" name="get_qw" hw=""/>
     <hwreg width="32" desc="Number of received Byte GET requests." sw="ro" counter="1" name="get_byte" hw=""/>
    </reg64>
    <reg64 desc="Responder network input performance counters. (part 1)" _absoluteAddress="0x16012a8" name="responder_perf_in_1">
     <hwreg width="32" desc="Number of received LOCK requests from the network." sw="ro" counter="1" name="lock_np" hw=""/>
     <hwreg width="32" desc="Number of received LOCK requests from the network (via the completer unit)." sw="ro" counter="1" name="lock_compl" hw=""/>
    </reg64>
    <reg64 desc="Responder ATU related performance counters. (part 0)" _absoluteAddress="0x16012b0" name="responder_perf_atu_0">
     <hwreg width="32" desc="Number of requested address translations" sw="ro" counter="1" name="trans_req" hw=""/>
     <hwreg width="32" desc="Number of received successful translations." sw="ro" counter="1" name="trans_rcvd" hw=""/>
    </reg64>
    <reg64 desc="Responder ATU related performance counters. (part 1)" _absoluteAddress="0x16012b8" name="responder_perf_atu_1">
     <hwreg width="32" desc="Number of received failed translations, or translations that did not return the correct access type." sw="ro" counter="1" name="trans_rcvd_err" hw=""/>
    </reg64>
    <reg64 desc="Responder ATU related performance counters. (part 2)" _absoluteAddress="0x16012c0" name="responder_perf_atu_2">
     <hwreg width="32" desc="Fence requests received from the ATU instance." sw="ro" counter="1" name="fence_rcvd" hw=""/>
     <hwreg width="32" desc="Fence responses sent back to the ATU instance." sw="ro" counter="1" name="fence_answd" hw=""/>
    </reg64>
    <reg64 desc="Responder read engine related performance counters. (part 0)" _absoluteAddress="0x16012c8" name="responder_perf_re_0">
     <hwreg width="32" desc="Read requests issued towards the host interface." sw="ro" counter="1" name="rd_req" hw=""/>
    </reg64>
    <reg64 desc="Responder read engine related performance counters. (part 1)" _absoluteAddress="0x16012d0" name="responder_perf_re_1">
     <hwreg width="48" desc="How much data (in bytes) has been requested from the host interface. Important: Byte requests are not used for reads, so even if only 1 byte was to be accessed, this will result in a 4 byte host interface access! Similarly non-aligned addresses can cause more data to be read than is actually needed for the request. Writes clear this register." sw="rw" reset="48'b0" name="byte_req" hw="wo"/>
    </reg64>
    <reg64 desc="Responder read engine related performance counters. (part 2)" _absoluteAddress="0x16012d8" name="responder_perf_re_2">
     <hwreg width="32" desc="Number of read responses received from the host interface." sw="ro" counter="1" name="rd_resp" hw=""/>
     <hwreg width="32" desc="Number of erroneous read responses received from the host interface." sw="ro" counter="1" name="rd_resp_err" hw=""/>
    </reg64>
    <reg64 desc="Responder read engine related performance counters. (part 3)" _absoluteAddress="0x16012e0" name="responder_perf_re_3">
     <hwreg width="48" desc="How much data (in bytes) has been received from the host interface. Important: Byte requests are not used for reads, so even if only 1 byte was to be accessed, this will result in a 4 byte host interface access! Similarly non-aligned addresses can cause more data to be read than is actually needed for the request. Writes clear this register." sw="rw" reset="48'b0" name="byte_rcvd" hw="wo"/>
    </reg64>
    <reg64 desc="Responder network interface performance counters. (part 0)" _absoluteAddress="0x16012e8" name="responder_perf_out_0">
     <hwreg width="32" desc="Number of QW GET responses forwarded to the network interface." sw="ro" counter="1" name="get_qw" hw=""/>
     <hwreg width="32" desc="Number of Byte GET responses forwarded to the network interface." sw="ro" counter="1" name="get_byte" hw=""/>
    </reg64>
    <reg64 desc="Responder network interface performance counters. (part 1)" _absoluteAddress="0x16012f0" name="responder_perf_out_1">
     <hwreg width="32" desc="Number of LOCK responses (of which the request targeted the responder) forwarded to the network interface." sw="ro" counter="1" name="lock_resp" hw=""/>
     <hwreg width="32" desc="Number of LOCK responses (of which the request targeted the completer) forwarded to the network interface." sw="ro" counter="1" name="lock_compl" hw=""/>
    </reg64>
    <reg64 desc="Responder network interface performance counters. (part 2)" _absoluteAddress="0x16012f8" name="responder_perf_out_2">
     <hwreg width="32" desc="Number of responses that were not forwarded to the network interface, but did require a notification." sw="ro" counter="1" name="not" hw=""/>
    </reg64>
    <reg64 desc="Responder network interface performance counters. (part 3)" _absoluteAddress="0x1601300" name="responder_perf_out_3">
     <hwreg width="48" desc="Cycles in which any kind of information (header or data) was forwarded to the network interface." sw="ro" counter="1" name="np_cycle" hw=""/>
    </reg64>
    <reg64 desc="Responder network interface performance counters. (part 4)" _absoluteAddress="0x1601308" name="responder_perf_out_4">
     <hwreg width="48" desc="How much data (in bytes) has been forwarded to the network interface. Includes QW, Byte and Immediate PUT data bytes. This count specifies the amount of valid payload, even though the actual payload is always a multiple of 64 bit. Writes clear this register." sw="rw" reset="48'b0" name="byte_sent" hw="wo"/>
    </reg64>
    <reg64 desc="Responder notification performance counters." _absoluteAddress="0x1601310" name="responder_perf_noti">
     <hwreg width="32" desc="Total number of sent notifications." sw="ro" counter="1" name="sent" hw=""/>
     <hwreg width="32" desc="Number of notifications which were marked as interrupt." sw="ro" counter="1" name="int" hw=""/>
    </reg64>
    <reg64 desc="Completer network input performance counters. (part 0)" _absoluteAddress="0x1601318" name="completer_perf_in_0">
     <hwreg width="32" desc="Number of received quadword PUT requests." sw="ro" counter="1" name="put_qw" hw=""/>
     <hwreg width="32" desc="Number of received byte PUT requests." sw="ro" counter="1" name="put_byte" hw=""/>
    </reg64>
    <reg64 desc="Completer network input performance counters. (part 1)" _absoluteAddress="0x1601320" name="completer_perf_in_1">
     <hwreg width="32" desc="Number of received immediate PUT requests." sw="ro" counter="1" name="put_imm" hw=""/>
     <hwreg width="32" desc="Number of received notification PUT requests." sw="ro" counter="1" name="put_noti" hw=""/>
    </reg64>
    <reg64 desc="Completer network input performance counters. (part 2)" _absoluteAddress="0x1601328" name="completer_perf_in_2">
     <hwreg width="32" desc="Number of received quadword GET responses." sw="ro" counter="1" name="get_qw" hw=""/>
     <hwreg width="32" desc="Number of received byte GET responses." sw="ro" counter="1" name="get_byte" hw=""/>
    </reg64>
    <reg64 desc="Completer network input performance counters. (part 3)" _absoluteAddress="0x1601330" name="completer_perf_in_3">
     <hwreg width="32" desc="Number of received LOCK requests." sw="ro" counter="1" name="lock_req" hw=""/>
     <hwreg width="32" desc="Number of received LOCK responses." sw="ro" counter="1" name="lock_resp" hw=""/>
    </reg64>
    <reg64 desc="Completer network input performance counters. (part 4)" _absoluteAddress="0x1601338" name="completer_perf_in_4">
     <hwreg width="48" desc="Completer network input received payload data in byte." sw="rw" reset="48'b0" name="byte_rcvd" hw="wo"/>
    </reg64>
    <reg64 desc="Completer ATU related performance counters. (part 0)" _absoluteAddress="0x1601340" name="completer_perf_atu_0">
     <hwreg width="32" desc="Number of requested address translations" sw="ro" counter="1" name="trans_req" hw=""/>
     <hwreg width="32" desc="Number of received successful translations." sw="ro" counter="1" name="trans_rcvd" hw=""/>
    </reg64>
    <reg64 desc="Completer ATU related performance counters. (part 1)" _absoluteAddress="0x1601348" name="completer_perf_atu_1">
     <hwreg width="32" desc="Number of received failed translations, or translations that did not return the correct access type." sw="ro" counter="1" name="trans_rcvd_err" hw=""/>
    </reg64>
    <reg64 desc="Completer ATU related performance counters. (part 2)" _absoluteAddress="0x1601350" name="completer_perf_atu_2">
     <hwreg width="32" desc="Fence requests received from the ATU instance." sw="ro" counter="1" name="fence_rcvd" hw=""/>
     <hwreg width="32" desc="Fence responses sent back to the ATU instance." sw="ro" counter="1" name="fence_answd" hw=""/>
    </reg64>
    <reg64 desc="Completer output (HTAX) performance counters. (part 0)" _absoluteAddress="0x1601358" name="completer_perf_out_0">
     <hwreg width="32" desc="Number of sent posted requests." sw="ro" counter="1" name="posted_req" hw=""/>
    </reg64>
    <reg64 desc="Completer output (HTAX) performance counters. (part 1)" _absoluteAddress="0x1601360" name="completer_perf_out_1">
     <hwreg width="48" desc="Completer HTAX output payload traffic in bytes." sw="rw" reset="48'b0" name="byte_sent" hw="wo"/>
    </reg64>
    <reg64 desc="Completer notification performance counters." _absoluteAddress="0x1601368" name="completer_perf_noti">
     <hwreg width="32" desc="Total number of sent notifications." sw="ro" counter="1" name="sent" hw=""/>
     <hwreg width="32" desc="Number of notifications which were marked as interrupt." sw="ro" counter="1" name="int" hw=""/>
    </reg64>
   </regroot>
  </regroot>
 </regroot>
 <vendorsettings>
  <!-- This block contains vendor specific settings and is simply copied over to the anotated format-->
  <npcount>4</npcount>
  <!-- Number of network ports in the EXTOLL design -->
  <lpcount>4</lpcount>
  <!-- Number of link ports in the EXTOLL design -->
  <rltinstances>8</rltinstances>
  <!-- Number of routing tables in the design (Identical to the number of Extoll crossbar inports) -->
  <rltportbitsdet>3</rltportbitsdet>
  <!-- Bits of the decimal Port identifier within a routing table entry -->
  <rltportbitsadapt>6</rltportbitsadapt>
  <!-- The number of bits that are used to enable/disable the adaptive routing entry ports -->
  <rltincnp>0</rltincnp>
  <!-- Do the routing table entries include the network ports? If so then "linkport ID = routing ID - <npcount>" -->
  <rltvcbits>2</rltvcbits>
  <!-- Bits of the VirtualChannel identifier within a routing table entry -->
  <rlttcbits>2</rlttcbits>
  <!-- Bits of the traffic class identifier of the routing format (there are a total of 2^rlttcs traffic classes -->
  <rltatcs>2</rltatcs>
  <!-- Number of adaptive routing traffic classes. Adaptive routing entries come above the deterministic entries for both the traffic class IDs as well as the routing table entries -->
  <rltdtcs>2</rltdtcs>
  <!-- Number of deterministic routing traffic classes -->
  <rltlocalbits>10</rltlocalbits>
  <!-- The 16 bit unit ID is split into local and global address bits, this specifies the number of local bits -->
  <rltglobalbits>6</rltglobalbits>
  <!-- The 16 bit unit ID is split into local and global address bits, this specifies the number of global bits -->
  <exelerate>0</exelerate>
  <!-- If value is >0 then the exelerate interface is instantiated in the EXTOLL design. Has impact on adaptive routing entries -->
  <rltentryperaddr>1</rltentryperaddr>
  <!-- How many routing table entries are located behind a 64 bit addressing routing table address. Valid values are 1 and 2 -->
 </vendorsettings>
</regfile>
